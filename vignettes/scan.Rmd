---
title: "Automatic Substitution"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Automatic Substitution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


> **Important**
> 
> Enabling automatic substitution is discouraged, as it increases the 
> likelihood of bugs and mistakes.


Setting `scan = TRUE` tells jobqueue to parse `expr` and automatically add any needed 
variables to `vars`.

As with most settings, you can add `scan = TRUE` to either `Queue$new()` or `<Queue>$run()`

```r
library(jobqueue)
q <- Queue$new(scan = TRUE)

x <- 3
y <- 5

q$run({ x + y })$result
#> [1] 8
```

You can change where variables are sourced from with the `envir` parameter.

If you assign a list, data.frame, etc to `envir`, it will be coerced to an 
environment with `baseenv()` as its parent.

```r
expr_args <- list(x = 4, y = 1)
q$run({ x + y }, envir = expr_args)$result
#> [1] 5
```


In this mode, you'll need to be very careful about which environment each variable is being drawn from. Variables will be looked up from environments in the following order:

1. `<Job>$vars`
2. Worker's `.GlobalEnv`
3. `<Job>$envir`, excluding `<Job>$ignore`
4. Worker's search path (packages)

Note how `scan = TRUE` will favor:

* Worker globals over `<Job>$envir`
* `<Job>$envir` over Worker's package functions

```r
q <- Queue$new(
  globals = list(x = 10),
  scan    = TRUE)

x <- 3
job <- q$run({ x })
job$result
#> [1] 10

job <- local({
  sum <- length
  q$run({ sum(c(300,80)) })
})
job$result
#> [1] 2
```

For comparison:

|    | `scan = FALSE`            | `scan = TRUE`                           |
|----|---------------------------|-----------------------------------------|
| 1. | `<Job>$vars`              | `<Job>$vars`                            |
| 2. | Worker's search path      | Worker's `.GlobalEnv`                   |
| 3. |                           | `<Job>$envir`, excluding `<Job>$ignore` |
| 4. |                           | Worker's search path                    |


#### Job Submission Triggers Variable Lookup

Note that `<Job>$envir` is not passed in its entirety to the Worker.
Rather, jobqueue extracts just the necessary variables from `<Job>$envir` and 
adds them to `<Job>$vars`.

This happens when the Job is submitted - either with `<Queue>$run()` or 
`<Queue>$submit(<Job>)`. If you examine `<Job>$vars` from a callback hook, 
you will see the updated `<Job>$vars` from the `'queued'` state onward.

```r
q <- Queue$new(scan = TRUE)
x <- 3; y <- 5
hooks <- list('*' = ~{ cat(sprintf('%10s: ', .$state)); dput(.$vars) })
job   <- q$run({ x + y }, hooks = hooks)
#>    created: list()
#>  submitted: list()
#>     queued: list(x = 3, y = 5)
#> dispatched: list(x = 3, y = 5)
#>   starting: list(x = 3, y = 5)
#>    running: list(x = 3, y = 5)
#>       done: list(x = 3, y = 5)
```

For details on callback hooks see `vignette('hooks')`.
