% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/queue.r
\name{Queue}
\alias{Queue}
\title{Interruptible, Asynchronous Background Jobs.}
\description{
Submit your jobs to a Queue and it will run them on a background R
process when one becomes available. Jobs are launched in the same order as
they are submitted, but may finish in a different order based on each job's
run time. Treat the returned Job object as a promise for asynchronous
downstream processing of the job's result.

Starts R sessions that run in the background. Calls to \code{run()} evaluate R
functions on these background sessions. \code{run()} returns a \link{Job}
object which can be passed to \code{then()} to schedule work to be done on the
result, when it is ready.

The \link{Job} object also has a \verb{$stop()} element which can be called to return
a result immediately. If the job was actively running in a background R
session, that process is killed and a new process is started to take its
place.
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{jobs}}{List of \link{Job}s currently managed by this Queue.}

\item{\code{workers}}{List of \link{Worker}s used to process Jobs.}

\item{\code{uid}}{Unique identifier, e.g. 'Q1'.}

\item{\code{loaded}}{List of global variables and attached functions on the Workers.}

\item{\code{state}}{Current state: starting, active, stopped, or error.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Queue-new}{\code{Queue$new()}}
\item \href{#method-Queue-print}{\code{Queue$print()}}
\item \href{#method-Queue-run}{\code{Queue$run()}}
\item \href{#method-Queue-submit}{\code{Queue$submit()}}
\item \href{#method-Queue-shutdown}{\code{Queue$shutdown()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Queue-new"></a>}}
\if{latex}{\out{\hypertarget{method-Queue-new}{}}}
\subsection{Method \code{new()}}{
Creates n \code{workers} background processes for handling \verb{$run()} and
\verb{$submit()} calls. These workers are initialized according to the
\code{globals}, \code{packages}, \code{init}, and \code{options} arguments. The Queue will
not use more than \code{max_cpus} at once, assuming the \code{cpus} argument is
properly set for each Job.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Queue$new(
  globals = NULL,
  packages = NULL,
  init = NULL,
  max_cpus = availableCores(omit = 1L),
  workers = ceiling(max_cpus * 1.2),
  options = r_session_options(),
  tmax = NULL,
  hooks = NULL,
  reformat = TRUE,
  stop_id = NULL,
  copy_id = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{globals}}{A list or similar set of values that are added to the
\code{.GlobalEnv} of workers.}

\item{\code{packages}}{Character vector of package names to load on workers.}

\item{\code{init}}{A call or R expression wrapped in curly braces to evaluate on
each worker just once, immediately after start-up. Will have access
to any variables defined by \code{globals} and assets from \code{packages}.
Returned value is ignored.}

\item{\code{max_cpus}}{Total number of CPU cores that can be reserved all running
Jobs via their combined \code{cpus} arguments. Does not enforce limits on
actual CPU utilization.}

\item{\code{workers}}{How many background \link{Worker} processes to start. Set to more
than \code{max_cpus} to enable interrupted workers to be quickly swapped
out with standby Workers while a replacement Worker boots up.}

\item{\code{options}}{Passed to \code{callr::r_session$new()}}

\item{\code{tmax, hooks, reformat, stop_id, copy_id}}{Defaults for this Queue's \verb{$run()} method. Here, \code{stop_id} and
\code{copy_id} must be a \verb{function (job)} or \code{NULL}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{Queue} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Queue-print"></a>}}
\if{latex}{\out{\hypertarget{method-Queue-print}{}}}
\subsection{Method \code{print()}}{
Print method for a \code{Queue}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Queue$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments are not used currently.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Queue-run"></a>}}
\if{latex}{\out{\hypertarget{method-Queue-run}{}}}
\subsection{Method \code{run()}}{
Creates a Job object and submits it to the queue for running on a
background process. Here, the default \code{NA} value will use the value set
by \code{Queue$new()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Queue$run(
  expr,
  vars = NULL,
  scan = is.null(vars),
  ignore = NULL,
  tmax = NA,
  hooks = NA,
  reformat = NA,
  cpus = 1L,
  stop_id = NA,
  copy_id = NA,
  start = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{A call or R expression wrapped in curly braces to evaluate on a
worker. Will have access to any variables defined by \code{vars}, as well
as the Worker's \code{globals}, \code{packages}, and \code{init} configuration.}

\item{\code{vars}}{A list of named variables to make available to \code{expr} during
evaluation.}

\item{\code{scan}}{Should additional variables be added to \code{vars} based on
scanning \code{expr} for missing global variables? By default,
\code{scan = is.null(vars)}, meaning if you set \code{vars = list()} then no
scan is done. Set \code{scan = TRUE} to always scan, \code{scan = FALSE} to
never scan, and \verb{scan = <an environment-like object>} to look for
globals there. When scanning, the worker's environment is taken into
account, and globals on the worker are favored over globals locally.
\code{vars} defined by the user are always left untouched.}

\item{\code{ignore}}{A character vector of variable names that should NOT be added
to \code{vars} by \code{scan}.}

\item{\code{tmax}}{A named numeric vector indicating the maximum number of
seconds allowed for each state the job passes through, or 'total' to
apply a single timeout from 'submitted' to 'done'. Example:
\code{tmax = c(total = 2.5, running = 1)} will force-stop a job 2.5
seconds after it is submitted, and also limits its time in the
running state to just 1 second.}

\item{\code{hooks}}{A list of functions to run when the Job state changes, of the
form \code{hooks = list(created = function (job) {...}, done = ~{...})}.
The names of these functions should be \code{created}, \code{submitted},
\code{queued}, \code{dispatched}, \code{starting}, \code{running}, \code{done}, or \code{'*'}.
\code{'*'} will be run every time the state changes, whereas the others
will only be run when the Job enters that state. Duplicate names are
allowed.}

\item{\code{reformat}}{The underlying call to \code{callr::r_session$call()} returns
information on stdout, stderr, etc. When \code{reformat=TRUE} (the
default), only the result of the expression is returned. Set
\code{reformat=FALSE} to return the entire callr output, or
\verb{reformat=function(job,output)} to use a function of your own to
post-process the output from callr.}

\item{\code{cpus}}{How many CPU cores to reserve for this Job. The \link{Queue} uses
this number to limit the number of simultaneously running Jobs; it
does not prevent a Job from using more CPUs than reserved.}

\item{\code{stop_id}}{If an existing \link{Job} in the Queue has the same \code{stop_id},
that Job will be stopped and return an 'interrupt' condition object
as its result. \code{stop_id} can also be a \verb{function (job)} that returns
the \code{stop_id} to assign to a given Job. A \code{stop_id} of \code{NULL}
disables this feature.}

\item{\code{copy_id}}{If an existing \link{Job} in the Queue has the same \code{copy_id},
the newly submitted Job will become a "proxy" for that earlier Job,
returning whatever result the earlier Job returns. \code{copy_id} can also
be a \verb{function (job)} that returns the \code{copy_id} to assign to a given
Job. A \code{copy_id} of \code{NULL} disables this feature.}

\item{\code{start}}{Should a Job be submitted to the Queue (\code{start = TRUE}) or
just created (\code{start = FALSE})?}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The new \link{Job} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Queue-submit"></a>}}
\if{latex}{\out{\hypertarget{method-Queue-submit}{}}}
\subsection{Method \code{submit()}}{
Adds a Job to the Queue for running on a background process.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Queue$submit(job)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{job}}{A \link{Job} object, as created by \code{Job$new()}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
This Queue, invisibly.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Queue-shutdown"></a>}}
\if{latex}{\out{\hypertarget{method-Queue-shutdown}{}}}
\subsection{Method \code{shutdown()}}{
Stop all jobs and workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Queue$shutdown(reason = "job queue shut down by user")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{reason}}{Passed to \verb{<Job>$stop(reason)} for any Jobs currently
managed by this Queue.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
This Queue, invisibly.
}
}
}
