[{"path":[]},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement dansmith01@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://cmmr.github.io/jobqueue/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 jobqueue authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Expressions and Variables","text":"call <jobqueue>$run(expr), calling environment visible expr. Therefore, variables needed expr must explicitly provided $run(vars = list()) previously set jobqueue(globals = list()) constructor.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"expressions","dir":"Articles","previous_headings":"","what":"Expressions","title":"Expressions and Variables","text":"expr parameter can given two ways. expr = { 42 } expr = quote({ 42 }) second form helpful expression needs passed around code handed <jobqueue>$run(). call-generating functions can used instead quote(), call() bquote().","code":"library(jobqueue) jq <- jobqueue()  jq$run({ 42 })$result #> [1] 42  expr <- quote({ 42 }) jq$run(expr)$result #> [1] 42"},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"variables","dir":"Articles","previous_headings":"","what":"Variables","title":"Expressions and Variables","text":"Global variables can set jobqueue created. Additional variables job can defined $run(vars = list()).","code":"globals <- list(MY_DATA = mtcars) jq      <- jobqueue(globals = globals)  expr <- quote(colnames(MY_DATA)) jq$run(expr)$result[1:6] #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\" expr <- quote(MY_DATA[rows,cols]) vars <- list(rows = 20:22, cols = c('mpg', 'hp', 'wt'))  jq$run(expr = expr, vars = vars)$result #>                   mpg  hp    wt #> Toyota Corolla   33.9  65 1.835 #> Toyota Corona    21.5  97 2.465 #> Dodge Challenger 15.5 150 3.520"},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"functions","dir":"Articles","previous_headings":"","what":"Functions","title":"Expressions and Variables","text":"remote environment inherits R’s baseenv(), can call base functions usual. use function package, call :: notation. use custom function, pass like variable. remember, like expr, functions access local environment. Functions packages exception - retain access namespace passed variable. ’re using lot functions package, can set jobqueue(packages = '<packageName>'), call package’s functions without :: notation. ’re package developer, can set jobqueue(namespace = '<yourPackageName>') give remote environment access functions variables (exported non-exported) defined package’s namespace. Note however package must installed changes take effect remote environment. .e. devtools::load_all() won’t cut ; R CMD INSTALL needed (via devtools::install(), pak::install_local(), etc).","code":"jq$run({ rep(2, 5) })$result #> [1] 2 2 2 2 2 jq$run({ jsonlite::toJSON(list(x = 42)) })$result #> {\"x\":[42]} f <- function (x) x * 2 jq$run({ f(x) }, vars = list(f=f, x=5))$result #> [1] 10 x <- 5 f <- function () x * 2 f() #> [1] 10  jq$run({ f() }, vars = list(f=f))$result #> <simpleError in f(): object 'x' not found> x <- list(x = 42) f <- jsonlite::toJSON jq$run({ f(x) }, vars = list(f=f, x=x))$result #> {\"x\":[42]}"},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Expressions and Variables","text":"defined two global variables: B. also attached ‘jsonlite’ R package search path. expr evaluated, uses toJSON, , B remote environment, x vars.","code":"library(jobqueue)  jq <- jobqueue(   globals  = list(A = 1),   init     = { B <- 12 },   packages = 'jsonlite' )  job <- jq$run(   'vars' = list(x = 37),    'expr' = { toJSON(c(A, B, x)) } )  job$result #> [1,12,37]"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Callback Hooks","text":"","code":"library(jobqueue) jq <- jobqueue(workers = 1)"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Callback Hooks","text":"Callbacks cornerstone asynchronous programming. want calculate 2 + 2 show results, synchronous programming approach : asynchronous programming, task broken apart two discrete steps: computation result handling. Using jobqueue, looks like: asynchronous format allows parts code run independently, case separate R processes. part finishes, callback executed allow work result. Callbacks limited just job finishing. See “State Triggers” section list events can trigger callback. Important Hooks evaluated main process, background processes. Therefore, ensure callback functions execute quickly delay job handling.","code":"message('Result = ', 2 + 2) #> Result = 20 job <- jq$run({ 2 + 2 }) job$on('done', ~message('Result = ', .$result)) #> Result = 20"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"a-callback-function","dir":"Articles","previous_headings":"","what":"A Callback Function","title":"Callback Hooks","text":"callback function accept one argument: object triggered callback. Functions accepting zero multiple arguments also allowed. great place R’s new shorthand function definitions (R >= 4.1.0). Lambda syntax can also used (see rlang::as_function()).","code":"# jobqueue hooks hook <- function (jq) { message('jobqueue is ', jq$state) } hook <- \\(jq) message('jobqueue is ', jq$state) hook <- ~message('jobqueue is ', .$state)  # worker hooks hook <- function (worker) { message('worker is ', worker$state) } hook <- \\(w) message('worker is ', w$state) hook <- ~message('worker is ', .$state)  # job hooks hook <- function (job) { message('job is ', job$state) } hook <- \\(j) message('job is ', j$state) hook <- ~message('job is ', .$state)"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"triggers","dir":"Articles","previous_headings":"","what":"Triggers","title":"Callback Hooks","text":"jobqueue, worker, job objects update $state described tables . time state changes, callbacks registered state executed. addition, can register state = '*' state='.next' trigger regardless present state name.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"attaching","dir":"Articles","previous_headings":"","what":"Attaching","title":"Callback Hooks","text":"Callbacks can attached jobqueue, worker, job objects. can add callbacks either constructor, later $(). jobqueue(), hooks can set hooks jobqueue, worker, job. rules : Prefixing q_, w_, j_ attaches hook jobqueue, worker, job, respectively. Non-prefixed hooks attached jobs. Alternatively, list lists can assigned hooks, format:","code":"hook <- ~message(.$uid, ' is ', .$state)  jq <- jobqueue(hooks         = list(q_idle = hook)) w  <- worker_class$new(hooks = list(idle   = hook)) j  <- job_class$new(hooks    = list(done   = hook))  jq$on('busy',    hook) w$on('busy',     hook) j$on('starting', hook) jobqueue(   'hooks' = list(     'queue'  = list(idle = hook),      'worker' = list(idle = hook),      'job'    = list(done = hook) ))"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"removing","dir":"Articles","previous_headings":"","what":"Removing","title":"Callback Hooks","text":"Callbacks attached constructor removed. attach callback $(), return value function, , called, remove callback object.","code":"job <- job_class$new(   'expr'  = { 3.14 },    'hooks' = list(done = ~message('ABC')) )  off <- job$on('done', ~message('XYZ')) off()  jq$submit(job) #> ABC"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"default-job-hooks","dir":"Articles","previous_headings":"","what":"Default job Hooks","title":"Callback Hooks","text":"create jobqueue, can define set callbacks automatically apply jobs created <jobqueue>$run() command. jobqueue() know apply hooks job objects instead jobqueue worker objects? Unless otherwise indicated, jobqueue() hooks assumed jobs. can also explicitly specify hooks jobs using formats described “Attaching Callbacks” section . set hooks <jobqueue>$run(), hooks REPLACE job hooks jobqueue().","code":"n  <- 0 jq <- jobqueue(hooks = list(created = ~{ n <<- n + 1 } ))  for (i in 1:5) jq$run({ 'Hi' })  n #> [1] 5 jq <- jobqueue(hooks = list(j_created = ~{ n <<- n + 1 } )) # or jq <- jobqueue(hooks = list(job = list(created = ~{ n <<- n + 1 } ))) n  <- 0 jq <- jobqueue(hooks = list(created = ~{ n <<- n + 1 } ))  for (i in 1:3) jq$run({ 'Hi' }, hooks = list(done = ~message(.$result))) #> Hi #> Hi #> Hi  n #> [1] 0"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"use-case-priority-setting","dir":"Articles","previous_headings":"","what":"Use Case: Priority Setting","title":"Callback Hooks","text":", ’ll set callback function triggers job enters 'queued' state. modify job, adding custom <job>$priority field job object. modify jobqueue‘s internal list jobs (<jobqueue>$jobs), sorting according job’s <job>$priority. Last, attach additional callbacks job output timing information upon exit 'queued’ state upon entry 'done' state. actual application, set <job>$priority based <job>$vars. , define custom <job>$priority field <jobqueue>$run(). , set <job>$priority hook triggers prioritize() triggered.","code":"library(glue) library(jobqueue)  # Our callback/hook function. prioritize <- function (job) {    queue      <- job$jobqueue   queue_jobs <- job$jobqueue$jobs    # Apply a random priority to this job.   job$priority <- round(runif(1) * 10) - 5      # Sort all this jobqueue's jobs by priority (including this job).   priorities        <- sapply(queue_jobs, `[[`, 'priority')   job$jobqueue$jobs <- queue_jobs[order(priorities)]      # Add hooks to this job to report queued/total times.   t1    <- Sys.time()   tdiff <- function () format(round(Sys.time() - t1, 1))      job$on('.next', ~message(glue(     'job {.$uid} (priority {.$priority}) was {.$state} after {tdiff()}' )))        job$on('done', ~message(glue(     'job {.$uid} (priority {.$priority}) finished in {tdiff()}' ))) }  # A single worker best illustrates processing order. jq <- jobqueue(   'workers' = 1,    'hooks'   = list(queued = prioritize) )  for (i in 1:5) {   job <- jq$run({ 3.14 })   message(glue_data(job, 'Created job {uid} with priority {priority}')) } #> job J11 (priority -3) was dispatched after 0.1 secs #> Created job J11 with priority -3 #> Created job J12 with priority -2 #> Created job J13 with priority 1 #> Created job J14 with priority 0 #> Created job J15 with priority -1 #> job J11 (priority -3) finished in 0.7 secs #> job J12 (priority -2) was dispatched after 0.6 secs #> job J12 (priority -2) finished in 1.1 secs #> job J15 (priority -1) was dispatched after 0.7 secs #> job J15 (priority -1) finished in 1.3 secs #> job J14 (priority 0) was dispatched after 1.4 secs #> job J14 (priority 0) finished in 2 secs #> job J13 (priority 1) was dispatched after 2.1 secs #> job J13 (priority 1) finished in 2.6 secs prioritize <- function (job) {      # Give priority to lower number of replications   job$priority <- job$vars$replications      queue_jobs        <- job$jobqueue$jobs   priorities        <- sapply(queue_jobs, `[[`, 'priority')   job$jobqueue$jobs <- queue_jobs[order(priorities)] } jq <- jobqueue(hooks = list(queued = prioritize))  #                                         vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv for (reps in 5:1) job <- jq$run({ 3.14 }, vars = list(replications = reps)) prioritize <- function (job) {   queue_jobs        <- job$jobqueue$jobs   priorities        <- sapply(queue_jobs, `[[`, 'priority')   job$jobqueue$jobs <- queue_jobs[order(priorities)] } jq <- jobqueue(hooks = list(queued = prioritize))  #                                         vvvvvvvvvvvvvvv for (reps in 5:1) job <- jq$run({ 3.14 }, priority = reps) set_priority <- function (job) {   job$priority <- job$vars$replications }  prioritize <- function (job) {   queue_jobs        <- job$jobqueue$jobs   priorities        <- sapply(queue_jobs, `[[`, 'priority')   job$jobqueue$jobs <- queue_jobs[order(priorities)] }  #                           vvvvvvvvvvvvvvvvvvvvvv jq <- jobqueue(hooks = list(created = set_priority, queued = prioritize)) for (reps in 5:1) job <- jq$run({ 3.14 }, vars = list(replications = reps))"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"use-case-rate-limiting","dir":"Articles","previous_headings":"","what":"Use Case: Rate Limiting","title":"Callback Hooks","text":"Say ’re hosting web service, users allowed submit one job every 30 seconds. jobs can take 30 seconds, solution complex setting stop_id = user_id. want stop new job instead old one? Note code won’t completely solve rate limiting task. user’s job takes five seconds complete, submit job every six seconds jobqueue none wiser. give jobqueue awareness previously completed jobs, ’ll need persistently store per-user job start times - like solution. first example, attached hook 'submitted' ’s <job>$jobqueue becomes available callbacks. latter example, attached hook 'created' instead didn’t need <job>$jobqueue solution. Check trigger order listed “Callback Triggers” section , attach callbacks early possible expedite job handling.","code":"rate_limit <- function (job) {    job$t_start <- Sys.time()    for (j in job$jobqueue$jobs)     if (j$user_id == job$user_id)       if (job$t_start - j$t_start < 30)         job$stop('Rate Limit Exceeded') }  jq <- jobqueue(hooks = list(submitted = rate_limit))  j_A1 <- jq$run({ 42 }, user_id = 'A') j_B1 <- jq$run({ 42 }, user_id = 'B') j_B2 <- jq$run({ 42 }, user_id = 'B')  j_B1$result #> [1] 42  j_B2$result #> <interrupt: Rate Limit Exceeded> t_user <- list()  rate_limit <- function (job) {   t_start <- Sys.time()   t_diff  <- t_user[[job$user_id]] - t_start   if (isTRUE(t_diff < 30)) { job$stop('Rate Limit Exceeded')   }   else                     { t_user[[job$user_id]] <<- t_start } }  jq <- jobqueue(hooks = list(created = rate_limit))"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"create-a-jobqueue","dir":"Articles","previous_headings":"","what":"Create a jobqueue","title":"Introduction to jobqueue","text":"create jobqueue, several worker processes created background. can evaluate R code background processes main R process free work. Important background processes persisent R sessions. Avoid modifying .GlobalEnv, otherwise R code produce different results based worker evaluates .","code":"library(jobqueue) jq <- jobqueue()"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"create-a-job","dir":"Articles","previous_headings":"","what":"Create a job","title":"Introduction to jobqueue","text":"Main article: vignette('eval') job begin evaluating immediately, assuming jobs ahead jobqueue.","code":"job <- jq$run({ paste('Hello', 'World!') })"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"access-the-result","dir":"Articles","previous_headings":"","what":"Access the Result","title":"Introduction to jobqueue","text":"Main article: vignette('results') Running <job>$result block job finishes result ready.","code":"job$result #> [1] \"Hello World!\""},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"add-a-callback-hook","dir":"Articles","previous_headings":"","what":"Add a Callback Hook","title":"Introduction to jobqueue","text":"Main article: vignette('hooks') Adding callback hook trigger Job done allows result handled without blocking main R process.","code":"job$on('done', function (job) message(job$result)) #> [1] \"Hello World!\""},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"interrupt-evaluation","dir":"Articles","previous_headings":"","what":"Interrupt Evaluation","title":"Introduction to jobqueue","text":"Main article: vignette('stops') job’s result longer needed want free compute resources, calling <job>$stop() terminate background process. Terminated background process automatically replaced new ones.","code":"job <- jq$run({ Sys.sleep(10); 'Zzzzz' }) job$stop() job$result #> <interrupt: job stopped by user>"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"passing-data","dir":"Articles","previous_headings":"","what":"Passing Data","title":"Introduction to jobqueue","text":"","code":"# Variables to permanently store on the Worker. jq <- jobqueue(globals = list(MY_DATA = mtcars))  # Variables to temporary add to the Worker. vars <- list(n = 2, fields = c('mpg', 'cyl', 'disp'))  # The expression to evaluate on the Worker. expr <- quote(head(MY_DATA, n)[,fields])  job <- jq$run(expr = expr, vars = vars)  job$result #>               mpg cyl disp #> Mazda RX4      21   6  160 #> Mazda RX4 Wag  21   6  160"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"reacting-to-results","dir":"Articles","previous_headings":"","what":"Reacting to Results","title":"Result and Error Handling","text":"See also vignette('hooks')","code":"library(jobqueue) jq <- jobqueue()  my_job <- jq$run({ 42 })  # ===  A 'jobqueue'-style callback  ============ my_job$on('done', ~message('Result = ', .$result)) #> Result = 42  # ===  A 'promises'-style callback  ============ my_job %...>% message('Result = ', .) #> Result = 42"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"output-vs-result","dir":"Articles","previous_headings":"","what":"Output vs Result","title":"Result and Error Handling","text":"expr finished evaluating, result assigned <job>$output. default, <job>$result return exact value <job>$output. However, <job>$output fixed value, <job>$result highly configurable. notably reformat signal parameters.","code":"job <- jq$run({ 42 })  job$output #> [1] 42 job$result #> [1] 42"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"reformatting-output","dir":"Articles","previous_headings":"","what":"Reformatting Output","title":"Result and Error Handling","text":"Use reformat = function (job) {...} define returned <job>$result. Important may access job$output reformat function. access job$result, start infinite recusion. reformat can set several places: jobqueue(reformat = http_wrap) <jobqueue>$run(reformat = http_wrap) <job>$reformat <- http_wrap","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"transformation","dir":"Articles","previous_headings":"Reformatting Output","what":"Transformation","title":"Result and Error Handling","text":"","code":"http_wrap <- function (job) {   result <- job$output   paste0('{\"status\":200,\"body\":{\"result\":', result, '}}') }  job <- jq$run({ 42 }, reformat = http_wrap) cat(job$result) #> {\"status\":200,\"body\":{\"result\":42}}"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"job-details","dir":"Articles","previous_headings":"Reformatting Output","what":"job Details","title":"Result and Error Handling","text":"","code":"with_id <- function (job) {   list(result = job$output, id = job$id) }  job <- jq$run({ 42 }, reformat = with_id, id = 'abc') dput(job$result) #> list(result = 42, id = \"abc\")"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"non-blocking","dir":"Articles","previous_headings":"Reformatting Output","what":"Non-blocking","title":"Result and Error Handling","text":"<job>$output blocks job done. want <job>$result block, can return placeholder value instead.","code":"reformat <- function (job) {   if (job$is_done) { job$output                 }   else             { 'result not available yet' } }  job <- jq$run({ Sys.sleep(5); 42 }, reformat = reformat) job$result #> [1] \"result not available yet\"  job$state #> [1] \"running\""},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"signaling-errors","dir":"Articles","previous_headings":"","what":"Signaling Errors","title":"Result and Error Handling","text":"default, errors interrupts caught jobqueue returned condition object <job>$result. want errors continue propagating, set signal = TRUE. signals can caught usual try() tryCatch(). can also signal conditions catching others. Perhaps stopping job part “normal” workflow shouldn’t lumped errors.","code":"expr <- quote(stop('error XYZ'))  job <- jq$run(expr) x   <- job$result  inherits(x, 'condition') #> TRUE  x #> <simpleError in eval(expr, envir, enclos): error XYZ> job <- jq$run(expr, signal = TRUE) x   <- job$result #> Error: #> ! stop(\"error XYZ\") #> Caused by error: #> ! error XYZ #> Run `rlang::last_trace()` to see where the error occurred. print_cnd <- function (cnd) cli::cli_text('Caught {.type {cnd}}.')  job <- jq$run({ Sys.sleep(5) }, signal = TRUE)$stop() res <- tryCatch(job$result, error = print_cnd, interrupt = print_cnd) #> Caught an <interrupt> object.  res #> NULL  job <- jq$run({ stop('error XYZ') }, signal = TRUE) res <- tryCatch(job$result, error = print_cnd, interrupt = print_cnd) #> Caught an <error> object.  res #> NULL job <- jq$run({ Sys.sleep(5) }, signal = 'error')$stop() res <- tryCatch(job$result, error = print_cnd)  res #> <interrupt: job stopped by user>  job <- jq$run({ stop('error XYZ') }, signal = 'error') res <- tryCatch(job$result, error = print_cnd) #> Caught an <error> object.  res #> NULL"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"promise-handling","dir":"Articles","previous_headings":"","what":"Promise Handling","title":"Result and Error Handling","text":"can pass job directly function expects promise object, promises::promises::%...>%. functions re-exported jobqueue, calling library(promises) optional. default, errors interrupts caught jobqueue used promise fulfillment. Setting signal = TRUE cause errors interrupts sent promise’s rejection handler instead.","code":"jq$run({ 42 }) %...>% message #> 42 onFulfilled <- function (value) cli::cli_text('Fulfilled with {.type {value}}.') onRejected  <- function (err)   cli::cli_text('Rejected with {.type {err}}.')  job <- jq$run({ Sys.sleep(5) })$stop() job %>% then(onFulfilled, onRejected) #> Fulfilled with an <interrupt> object.  job <- jq$run({ stop('error XYZ') }) job %>% then(onFulfilled, onRejected) #> Fulfilled with an <error> object. job <- jq$run({ Sys.sleep(5) }, signal = TRUE)$stop() job %>% then(onFulfilled, onRejected) #> Rejected with an <interrupt> object.  job <- jq$run({ stop('error XYZ') }, signal = TRUE) job %>% then(onFulfilled, onRejected) #> Rejected with an <error> object."},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Stopping Jobs","text":"can save compute resources stopping execution jobs longer needed. job currently running, associated background process terminated. Terminated background process automatically replaced new ones. several ways stop Job: <job>$stop(): return interrupt condition. <job>$output<-: return custom result. <job>$stop_id: replace redundant jobs. <job>$copy_id: combine redundant jobs. <job>$timeout: cap job’s compute time.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Stopping Jobs","text":"","code":"library(jobqueue) jq <- jobqueue(workers = 1)"},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"immediate-stop","dir":"Articles","previous_headings":"","what":"Immediate Stop","title":"Stopping Jobs","text":"soon job created, can stopped either calling <job>$stop() assigning <job>$output. methods work job state 'done'. job state 'done', <job>$output immutable calling <job>$stop() effect (since ’s already stopped). Calling <job>$stop() assigning <job>$output side effect setting job state 'done'.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"interrupting-with-jobstop","dir":"Articles","previous_headings":"Immediate Stop","what":"Interrupting with <job>$stop()","title":"Stopping Jobs","text":"can call <job>$stop() within callback hooks.","code":"job <- job_class$new({ Sys.sleep(5); 10 }) job$stop() job$result #> <interrupt: job stopped by user>  job <- job_class$new({ Sys.sleep(5); 10 }) job$stop('my reason') job$result #> <interrupt: my reason>  class(job$result) #> [1] \"interrupt\" \"condition\" hooks <- list(   'created' = function (job) {     if (length(job$vars$x) > 100)       job$stop('Job is too large.')   } )  job <- jq$run({ sum(x) }, vars = list(x = 1:200), hooks = hooks) job$result #> <interrupt: Job is too large.>"},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"assigning-to-joboutput","dir":"Articles","previous_headings":"Immediate Stop","what":"Assigning to <job>$output","title":"Stopping Jobs","text":"<job>$output can assigned . job yet done <job>$output assigned, ongoing processing halted. ’ve set <job>$reformat, determine <job>$result usual. See vignette('results').","code":"job <- job_class$new({ Sys.sleep(5); 10 })  job$state #> [1] \"created\"  job$output <- \"Custom result\"  job$state #> [1] \"done\"  job$result #> [1] \"Custom result\""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"replacing-and-combining","dir":"Articles","previous_headings":"","what":"Replacing and Combining","title":"Stopping Jobs","text":"Sometimes repeat jobs may sent jobqueue, instance, user clicking ‘submit’ button repeatedly. stop_id copy_id can prevent requests overloading server.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"stop-id","dir":"Articles","previous_headings":"Replacing and Combining","what":"Stop ID","title":"Stopping Jobs","text":"New jobs replace existing jobs stop_id.","code":"job1 <- jq$run({ Sys.sleep(5); 'A' }, stop_id = 123) job2 <- jq$run({ 'B' },               stop_id = 123) job1$result #> <interrupt: duplicated stop_id> job2$result #> [1] \"B\""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"copy-id","dir":"Articles","previous_headings":"Replacing and Combining","what":"Copy ID","title":"Stopping Jobs","text":"New jobs mirror output existing jobs copy_id.","code":"job1 <- jq$run({ Sys.sleep(5); 'A' }, copy_id = 456) job2 <- jq$run({ 'B' },               copy_id = 456) job1$result #> [1] \"A\" job2$result #> [1] \"A\""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"in-jobqueue","dir":"Articles","previous_headings":"Replacing and Combining","what":"In jobqueue()","title":"Stopping Jobs","text":"set stop_id /copy_id jobqueue(), must functions (lambda notation functions) accept job object input returns value id. id NULL, comparisons done. Otherwise, id can data type compared ids identical().","code":"jq <- jobqueue(stop_id = function (job) list(job$vars$f, job$user_id))  job1 <- jq$run({ f(x) }, vars = list(f = sum,  x = 1:10), user_id = 'A') job2 <- jq$run({ f(x) }, vars = list(f = sum,  x = 1:2),  user_id = 'A') job3 <- jq$run({ f(x) }, vars = list(f = mean, x = 1:10), user_id = 'A')  job1$result #> <interrupt: duplicated stop_id> job2$result #> [1] 3 job3$result #> [1] 5.5"},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"timeouts","dir":"Articles","previous_headings":"","what":"Timeouts","title":"Stopping Jobs","text":"Limits (seconds) can set : total 'submitted' 'done' time: timeout = 2 per-state basis: timeout = list(queued = 1, running = 2) : timeout = list(total = 3, queued = 2, running = 2)","code":"job <- job_class$new({ Sys.sleep(5); 'Zzzzz' }, timeout = 0.2) jq$submit(job) job$result #> <interrupt: total runtime exceeded 0.2 seconds>  job <- job_class$new({ 10 }, timeout = list(created = 0.2)) job$result #> <interrupt: exceeded 0.2 seconds while in \"created\" state>"},{"path":"https://cmmr.github.io/jobqueue/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel P. Smith. Author, maintainer. Alkek Center Metagenomics Microbiome Research. Copyright holder, funder.","code":""},{"path":"https://cmmr.github.io/jobqueue/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith D (2025). jobqueue: Run Interruptible Code Asynchronously. R package version 1.6.6, https://cmmr.github.io/jobqueue/.","code":"@Manual{,   title = {jobqueue: Run Interruptible Code Asynchronously},   author = {Daniel P. Smith},   year = {2025},   note = {R package version 1.6.6},   url = {https://cmmr.github.io/jobqueue/}, }"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"jobqueue","dir":"","previous_headings":"","what":"Run Interruptible Code Asynchronously","title":"Run Interruptible Code Asynchronously","text":"goals jobqueue : Run jobs parallel background processes. Allow jobs stopped point. Process job results asynchronous callbacks.","code":""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Run Interruptible Code Asynchronously","text":"","code":"# Install the latest stable version from CRAN: install.packages(\"jobqueue\")  # Or the development version from GitHub: install.packages(\"pak\") pak::pak(\"cmmr/jobqueue\")"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Run Interruptible Code Asynchronously","text":"","code":"library(jobqueue)  jq <- jobqueue()  job <- jq$run({ paste('Hello', 'world!') }) job$result #> [1] \"Hello world!\""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"asynchronous-callbacks","dir":"","previous_headings":"","what":"Asynchronous Callbacks","title":"Run Interruptible Code Asynchronously","text":"Main articles: vignette('results') vignette('hooks')","code":"job <- jq$run(   expr  = { 42 },    hooks = list(     'created' = ~{ message(\"We're uid '\", .$uid, \"'.\") },     '*'       = ~{ message('  - ', .$state) })) #> We're uid 'J2'. #>   - created #>   - submitted #>   - queued #>   - starting #>   - running #>   - done  job$on('done', ~{ message('result = ', .$result) }) #> result = 42"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"converting-to-promises","dir":"","previous_headings":"Asynchronous Callbacks","what":"Converting to Promises","title":"Run Interruptible Code Asynchronously","text":"See also https://rstudio.github.io/promises/","code":"job      <- jq$run({ 3.14 }) callback <- function (result) message('resolved with: ', result)  job %...>% callback #> resolved with: 3.14  job %>% then(callback) #> resolved with: 3.14  as.promise(job)$then(callback) #> resolved with: 3.14"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"shiny-integration","dir":"","previous_headings":"Asynchronous Callbacks","what":"Shiny Integration","title":"Run Interruptible Code Asynchronously","text":"See also https://rstudio.github.io/promises/articles/promises_06_shiny.html","code":"function(input, output, session) {   output$plot <- renderPlot({     jq$run({ read.table(url) }, list(url = input$url)) %...>%       head(input$n) %...>%       plot()   }) }"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"stopping-jobs","dir":"","previous_headings":"","what":"Stopping Jobs","title":"Run Interruptible Code Asynchronously","text":"running job stopped, background process terminated. Terminated background process automatically replaced new ones. Stopped jobs return condition object class ‘interrupt’ result. Main article: vignette('stops')","code":""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"manually","dir":"","previous_headings":"Stopping Jobs","what":"Manually","title":"Run Interruptible Code Asynchronously","text":"custom message can also given, e.g. job$stop('reason'), returned condition object.","code":"job <- jq$run({ Sys.sleep(2); 'Zzzzz' }) job$stop() job$result #> <interrupt: job stopped by user>"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"runtime-limits","dir":"","previous_headings":"Stopping Jobs","what":"Runtime Limits","title":"Run Interruptible Code Asynchronously","text":"Limits (seconds) can set : total ‘submitted’ ‘done’ time: timeout = 2 per-state basis: timeout = list(queued = 1, running = 2) : timeout = list(total = 3, queued = 2, running = 2)","code":"job <- jq$run({ Sys.sleep(2); 'Zzzzz' }, timeout = 0.2) job$result #> <interrupt: total runtime exceeded 0.2 seconds>"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"stop-id","dir":"","previous_headings":"Stopping Jobs","what":"Stop ID","title":"Run Interruptible Code Asynchronously","text":"New jobs replace existing jobs stop_id.","code":"job1 <- jq$run({ Sys.sleep(1); 'A' }, stop_id = 123) job2 <- jq$run({ 'B' },               stop_id = 123) job1$result #> <superseded: duplicated stop_id> job2$result #> [1] \"B\""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"copy-id","dir":"","previous_headings":"Stopping Jobs","what":"Copy ID","title":"Run Interruptible Code Asynchronously","text":"New jobs mirror output existing jobs copy_id.","code":"job1 <- jq$run({ Sys.sleep(1); 'A' }, copy_id = 456) job2 <- jq$run({ 'B' },               copy_id = 456) job1$result #> [1] \"A\" job2$result #> [1] \"A\""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"variables","dir":"","previous_headings":"","what":"Variables","title":"Run Interruptible Code Asynchronously","text":"Main article: vignette('eval')","code":"jq2  <- jobqueue(globals = list(G = 8)) expr <- quote(c(x = x , y = y, G = G)) job  <- jq2$run(expr, vars = list(x = 10, y = 2))  dput(job$result) #> c(x = 10, y = 2, G = 8)  jq2$stop()"},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":null,"dir":"Reference","previous_headings":"","what":"Define an R Expression (R6 Class) — job_class","title":"Define an R Expression (R6 Class) — job_class","text":"job object encapsulates expression evaluation parameters. also provides way check retrieve result.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Define an R Expression (R6 Class) — job_class","text":"expr R expression run job. vars Get set - List variables placed expression's environment evaluation. reformat Get set - function (job) defining <job>$result. signal Get set - Conditions signal. cpus Get set - Number CPUs reserve evaluating expr. timeout Get set - Time limits apply job. proxy Get set - job proxy place running expr. state Get set - job's state: 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done'. Assigning <job>$state trigger callback hooks. output Get set - job's raw output. Assigning <job>$output change job's state 'done'. jobqueue jobqueue job belongs . worker worker job belongs . result Result expr. block job finished. hooks Currently registered callback hooks named list functions. Set new hooks <job>$(). is_done TRUE FALSE depending job's result ready. uid short string, e.g. 'J16', uniquely identifies job.","code":""},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Define an R Expression (R6 Class) — job_class","text":"job_class$new() job_class$print() job_class$() job_class$wait() job_class$stop()","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Define an R Expression (R6 Class) — job_class","text":"Creates job object defining run expression background worker process. Typically need call job_class$new(). Instead, create jobqueue use <jobqueue>$run() generate job objects.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an R Expression (R6 Class) — job_class","text":"","code":"job_class$new(   expr,   vars = NULL,   timeout = NULL,   hooks = NULL,   reformat = NULL,   signal = FALSE,   cpus = 1L,   ... )"},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an R Expression (R6 Class) — job_class","text":"expr call R expression wrapped curly braces evaluate worker. access variables defined vars, well worker's globals, packages, init configuration. See vignette('eval'). vars named list variables make available expr evaluation. Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. function (job) returns object. timeout named numeric vector indicating maximum number seconds allowed state job passes , 'total' apply single timeout 'submitted' 'done'. function (job) returns . Example: timeout = c(total = 2.5, running = 1). See vignette('stops'). hooks named list functions run job state changes, form hooks = list(created = function (worker) {...}). function (job) returns . Names worker hooks typically 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done', '*' (duplicates okay). See vignette('hooks'). reformat Set reformat = function (job) define <job>$result return. default, reformat = NULL passes <job>$output <job>$result unchanged. See vignette('results'). signal calling <job>$result signal condition objects? FALSE, <job>$result return object without taking additional action. Setting TRUE character vector condition classes, e.g. c('interrupt', 'error', 'warning'), cause equivalent stop(<condition>) called conditions produced. Alternatively, function (job) returns TRUE FALSE. See vignette('results'). cpus many CPU cores reserve job. function (job) returns . Used limit number jobs running simultaneously respect <jobqueue>$max_cpus. prevent job using CPUs reserved. ... Arbitrary named values add returned job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Define an R Expression (R6 Class) — job_class","text":"job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Define an R Expression (R6 Class) — job_class","text":"Print method job.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an R Expression (R6 Class) — job_class","text":"","code":"job_class$print(...)"},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an R Expression (R6 Class) — job_class","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Define an R Expression (R6 Class) — job_class","text":"job, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"method-on-","dir":"Reference","previous_headings":"","what":"Method on()","title":"Define an R Expression (R6 Class) — job_class","text":"Attach callback function execute job enters state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an R Expression (R6 Class) — job_class","text":"","code":"job_class$on(state, func)"},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an R Expression (R6 Class) — job_class","text":"state name job state. Typically one : '*' -          Every time state changes. '.next' -      one time, next time state changes. 'created' -    job_class$new() initialization. 'submitted' -  <job>$jobqueue assigned. 'queued' -     stop_id copy_id resolved. 'dispatched' - <job>$worker assigned. 'starting' -   evaluation begins. 'running' -    evaluation begins. 'done' -       <job>$output assigned. Custom states can also specified. func function accepts job object input. can call <job>$stop() edit <job>$ values changes persisted (since jobs reference class objects). can also edit/stop queued jobs modifying jobs <job>$jobqueue$jobs. Return value ignored.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Define an R Expression (R6 Class) — job_class","text":"function called removes callback job.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"method-wait-","dir":"Reference","previous_headings":"","what":"Method wait()","title":"Define an R Expression (R6 Class) — job_class","text":"Blocks job enters given state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an R Expression (R6 Class) — job_class","text":"","code":"job_class$wait(state = \"done\", timeout = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an R Expression (R6 Class) — job_class","text":"state name job state. Typically one : '*' -          Every time state changes. '.next' -      one time, next time state changes. 'created' -    job_class$new() initialization. 'submitted' -  <job>$jobqueue assigned. 'queued' -     stop_id copy_id resolved. 'dispatched' - <job>$worker assigned. 'starting' -   evaluation begins. 'running' -    evaluation begins. 'done' -       <job>$output assigned. Custom states can also specified. timeout Stop job takes longer number seconds, NULL.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Define an R Expression (R6 Class) — job_class","text":"job, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"Define an R Expression (R6 Class) — job_class","text":"Stop job. job running, worker restarted.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an R Expression (R6 Class) — job_class","text":"","code":"job_class$stop(reason = \"job stopped by user\", cls = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an R Expression (R6 Class) — job_class","text":"reason message include 'interrupt' condition object returned job's result. condition object. cls Character vector additional classes prepend c('interrupt', 'condition').","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/job_class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Define an R Expression (R6 Class) — job_class","text":"job, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigns Jobs to Workers — jobqueue","title":"Assigns Jobs to Workers — jobqueue","text":"Jobs go . Results come .","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers — jobqueue","text":"","code":"jobqueue(   globals = NULL,   packages = NULL,   namespace = NULL,   init = NULL,   max_cpus = availableCores(),   workers = ceiling(max_cpus * 1.2),   timeout = NULL,   hooks = NULL,   reformat = NULL,   signal = FALSE,   cpus = 1L,   stop_id = NULL,   copy_id = NULL )"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers — jobqueue","text":"globals named list variables <job>$exprs access . Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. packages Character vector package names load workers. namespace name package attach worker's environment. init call R expression wrapped curly braces evaluate worker just , immediately start-. access variables defined globals assets packages namespace. Returned value ignored. max_cpus Total number CPU cores can reserved running jobs (sum(<job>$cpus)). enforce limits actual CPU utilization. workers many background worker processes start. Set max_cpus enable standby workers quickly swap workers need restart. timeout named numeric vector indicating maximum number seconds allowed state job passes , 'total' apply single timeout 'submitted' 'done'. Can also limit 'starting' state workers. function (job) can used place number. Example: timeout = c(total = 2.5, running = 1). See vignette('stops'). hooks named list functions run job state changes, form hooks = list(created = function (worker) {...}). function (job) returns . Names worker hooks typically 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done', '*' (duplicates okay). See vignette('hooks'). reformat Set reformat = function (job) define <job>$result return. default, reformat = NULL passes <job>$output <job>$result unchanged. See vignette('results'). signal calling <job>$result signal condition objects? FALSE, <job>$result return object without taking additional action. Setting TRUE character vector condition classes, e.g. c('interrupt', 'error', 'warning'), cause equivalent stop(<condition>) called conditions produced. Alternatively, function (job) returns TRUE FALSE. See vignette('results'). cpus default number CPU cores per job. function (job) returns number CPU cores reserve given job. Used limit number jobs running simultaneously respect <jobqueue>$max_cpus. prevent job using CPUs reserved. stop_id existing job jobqueue stop_id, job stopped return 'interrupt' condition object result. stop_id can also function (job) returns stop_id assign given job. stop_id NULL disables feature. See vignette('stops'). copy_id existing job jobqueue copy_id, newly submitted job become \"proxy\" earlier job, returning whatever result earlier job returns. copy_id can also function (job) returns copy_id assign given job. copy_id NULL disables feature. See vignette('stops').","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assigns Jobs to Workers — jobqueue","text":"jobqueue object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assigns Jobs to Workers — jobqueue","text":"","code":"jq <- jobqueue(globals = list(N = 42), workers = 2) print(jq) #> ── Q1 <jobqueue/R6> ────────────────────── idle ── #>  #>     • 0 jobs - 0 are running #>     • 2 workers - 0 are busy #>     • 0 of 4 CPUs are currently in use #>  #> ────────────── 0 jobs run in 1 secs ──────────────  job <- jq$run({ paste(\"N is\", N) }) job$result #> [1] \"N is 42\"  jq$stop()"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Jobs go . Results come .","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"hooks named list currently registered callback hooks. jobs Get set - List jobs currently managed jobqueue. state jobqueue's state: 'starting', 'idle', 'busy', 'stopped', 'error.' uid short string, e.g. 'Q1', uniquely identifies jobqueue. tmp jobqueue's temporary directory. workers Get set - List workers used processing jobs. cnd error caused jobqueue stop.","code":""},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"jobqueue_class$new() jobqueue_class$print() jobqueue_class$run() jobqueue_class$submit() jobqueue_class$wait() jobqueue_class$() jobqueue_class$stop()","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Creates pool background processes handling $run() $submit() calls. workers initialized according globals, packages, init arguments.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$new(   globals = NULL,   packages = NULL,   namespace = NULL,   init = NULL,   max_cpus = availableCores(),   workers = ceiling(max_cpus * 1.2),   timeout = NULL,   hooks = NULL,   reformat = NULL,   signal = FALSE,   cpus = 1L,   stop_id = NULL,   copy_id = NULL )"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"globals named list variables <job>$exprs access . Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. packages Character vector package names load workers. namespace name package attach worker's environment. init call R expression wrapped curly braces evaluate worker just , immediately start-. access variables defined globals assets packages namespace. Returned value ignored. max_cpus Total number CPU cores can reserved running jobs (sum(<job>$cpus)). enforce limits actual CPU utilization. workers many background worker processes start. Set max_cpus enable standby workers quickly swap workers need restart. timeout, hooks, reformat, signal, cpus, stop_id, copy_id Defaults jobqueue's $run() method. , stop_id copy_id must either function (job) NULL. hooks can set jobqueue, worker, /job hooks - see \"Attaching\" section vignette('hooks').","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"jobqueue object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Print method jobqueue.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$print(...)"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-run-","dir":"Reference","previous_headings":"","what":"Method run()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Creates job object submits jobqueue running. NA arguments replaced value jobqueue_class$new().","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$run(   expr,   vars = list(),   timeout = NA,   hooks = NA,   reformat = NA,   signal = NA,   cpus = NA,   stop_id = NA,   copy_id = NA,   ... )"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"expr call R expression wrapped curly braces evaluate worker. access variables defined vars, well jobqueue's globals, packages, init configuration. See vignette('eval'). vars named list variables make available expr evaluation. Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. function (job) returns object. timeout named numeric vector indicating maximum number seconds allowed state job passes , 'total' apply single timeout 'submitted' 'done'. Can also limit 'starting' state workers. function (job) can used place number. Example: timeout = c(total = 2.5, running = 1). See vignette('stops'). hooks named list functions run job state changes, form hooks = list(created = function (worker) {...}). function (job) returns . Names worker hooks typically 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done', '*' (duplicates okay). See vignette('hooks'). reformat Set reformat = function (job) define <job>$result return. default, reformat = NULL passes <job>$output <job>$result unchanged. See vignette('results'). signal calling <job>$result signal condition objects? FALSE, <job>$result return object without taking additional action. Setting TRUE character vector condition classes, e.g. c('interrupt', 'error', 'warning'), cause equivalent stop(<condition>) called conditions produced. Alternatively, function (job) returns TRUE FALSE. See vignette('results'). cpus many CPU cores reserve job. function (job) returns . Used limit number jobs running simultaneously respect <jobqueue>$max_cpus. prevent job using CPUs reserved. stop_id existing job jobqueue stop_id, job stopped return 'interrupt' condition object result. stop_id can also function (job) returns stop_id assign given job. stop_id NULL disables feature. See vignette('stops'). copy_id existing job jobqueue copy_id, newly submitted job become \"proxy\" earlier job, returning whatever result earlier job returns. copy_id can also function (job) returns copy_id assign given job. copy_id NULL disables feature. See vignette('stops'). ... Arbitrary named values add returned job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"new job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-submit-","dir":"Reference","previous_headings":"","what":"Method submit()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Adds job jobqueue running background process.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$submit(job)"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"job job object, created job_class$new().","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"jobqueue, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-wait-","dir":"Reference","previous_headings":"","what":"Method wait()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Blocks jobqueue enters given state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$wait(state = \"idle\", timeout = NULL, signal = TRUE)"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"state name jobqueue state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - workers starting. 'idle' -     workers ready/idle. 'busy' -     least one worker busy. 'stopped' -  Shutdown complete. timeout Stop jobqueue takes longer number seconds, NULL. signal Raise error encountered (also recorded <jobqueue>$cnd).","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"jobqueue, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-on-","dir":"Reference","previous_headings":"","what":"Method on()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Attach callback function execute jobqueue enters state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$on(state, func)"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"state name jobqueue state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - workers starting. 'idle' -     workers ready/idle. 'busy' -     least one worker busy. 'stopped' -  Shutdown complete. func function accepts jobqueue object input. Return value ignored.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"function called removes callback jobqueue.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"Stop jobs workers.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"","code":"jobqueue_class$stop(reason = \"jobqueue shut down by user\", cls = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"reason Passed <job>$stop() jobs currently managed jobqueue. cls Passed <job>$stop() jobs currently managed jobqueue.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/jobqueue_class.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to Workers (R6 Class) — jobqueue_class","text":"jobqueue, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. later later, run_now magrittr %<>%, %>% parallelly availableCores promises %...>%, %...T>%, .promise, promise_all, promise_map, promise_race, promise_reduce, ","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":null,"dir":"Reference","previous_headings":"","what":"A Background Process (R6 Class) — worker_class","title":"A Background Process (R6 Class) — worker_class","text":"job expressions evaluated.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"A Background Process (R6 Class) — worker_class","text":"hooks named list currently registered callback hooks. job currently running job. ps ps::ps_handle() object background process. state worker's state: 'starting', 'idle', 'busy', 'stopped'. uid short string, e.g. 'W11', uniquely identifies worker. tmp worker's temporary directory. cnd error caused worker stop.","code":""},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"A Background Process (R6 Class) — worker_class","text":"worker_class$new() worker_class$print() worker_class$start() worker_class$stop() worker_class$restart() worker_class$() worker_class$wait() worker_class$run()","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"A Background Process (R6 Class) — worker_class","text":"Creates background R process running jobs.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$new(   globals = NULL,   packages = NULL,   namespace = NULL,   init = NULL,   hooks = NULL,   wait = TRUE,   timeout = Inf )"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"globals named list variables <job>$exprs access . Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. packages Character vector package names load workers. namespace name package attach worker's environment. init call R expression wrapped curly braces evaluate worker just , immediately start-. access variables defined globals assets packages namespace. Returned value ignored. hooks named list functions run worker state changes, form hooks = list(idle = function (worker) {...}). Names worker hooks typically starting, idle, busy, stopped, '*' (duplicates okay). See vignette('hooks'). wait TRUE, blocks worker 'idle'. FALSE, worker object returned 'starting' state. timeout long wait worker finish starting (seconds). NA, defaults worker_class$new() argument.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"A Background Process (R6 Class) — worker_class","text":"Print method worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$print(...)"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"A Background Process (R6 Class) — worker_class","text":"Restarts stopped worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$start(wait = TRUE, timeout = NA)"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"wait TRUE, blocks worker 'idle'. FALSE, worker object returned 'starting' state. timeout long wait worker finish starting (seconds). NA, defaults worker_class$new() argument.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"A Background Process (R6 Class) — worker_class","text":"Stops worker terminating background process calling <job>$stop(reason) jobs currently assigned worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$stop(reason = \"worker stopped by user\", cls = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"reason Passed <job>$stop() jobs currently managed worker. cls Passed <job>$stop() jobs currently managed worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-restart-","dir":"Reference","previous_headings":"","what":"Method restart()","title":"A Background Process (R6 Class) — worker_class","text":"Restarts worker calling <worker>$stop(reason) <worker>$start() succession.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$restart(   wait = TRUE,   timeout = NA,   reason = \"restarting worker\",   cls = NULL )"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"wait TRUE, blocks worker 'idle'. FALSE, worker object returned 'starting' state. timeout long wait worker finish starting (seconds). NA, defaults worker_class$new() argument. reason Passed <job>$stop() jobs currently managed worker. cls Passed <job>$stop() jobs currently managed worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-on-","dir":"Reference","previous_headings":"","what":"Method on()","title":"A Background Process (R6 Class) — worker_class","text":"Attach callback function execute worker enters state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$on(state, func)"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"state name worker state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - Waiting background process load. 'idle' -     Waiting jobs $run(). 'busy' -     job running. 'stopped' -  <worker>$stop() called. func function accepts worker object input. can call <worker>$stop() <worker>$ methods.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"function called removes callback worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-wait-","dir":"Reference","previous_headings":"","what":"Method wait()","title":"A Background Process (R6 Class) — worker_class","text":"Blocks worker enters given state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$wait(state = \"idle\", timeout = Inf, signal = TRUE)"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"state name worker state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - Waiting background process load. 'idle' -     Waiting jobs $run(). 'busy' -     job running. 'stopped' -  <worker>$stop() called. timeout Stop worker takes longer number seconds. signal Raise error encountered (also recorded <worker>$cnd).","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"method-run-","dir":"Reference","previous_headings":"","what":"Method run()","title":"A Background Process (R6 Class) — worker_class","text":"Assigns job worker evaluation background process.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process (R6 Class) — worker_class","text":"","code":"worker_class$run(job)"},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process (R6 Class) — worker_class","text":"job job object, created job_class$new().","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/worker_class.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process (R6 Class) — worker_class","text":"worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/news/index.html","id":"jobqueue-160","dir":"Changelog","previous_headings":"","what":"jobqueue 1.6.0","title":"jobqueue 1.6.0","text":"CRAN release: 2025-04-01 Checks parent process still alive.","code":""},{"path":"https://cmmr.github.io/jobqueue/news/index.html","id":"jobqueue-151","dir":"Changelog","previous_headings":"","what":"jobqueue 1.5.1","title":"jobqueue 1.5.1","text":"CRAN release: 2025-02-28 Added namespace parameter.","code":""},{"path":"https://cmmr.github.io/jobqueue/news/index.html","id":"jobqueue-141","dir":"Changelog","previous_headings":"","what":"jobqueue 1.4.1","title":"jobqueue 1.4.1","text":"CRAN release: 2025-02-21 Default waiting Queue/Worker load. Allow functions job arguments. Re-export parallelly::availableCores().","code":""},{"path":"https://cmmr.github.io/jobqueue/news/index.html","id":"jobqueue-101","dir":"Changelog","previous_headings":"","what":"jobqueue 1.0.1","title":"jobqueue 1.0.1","text":"CRAN release: 2025-01-30 Initial CRAN submission.","code":""}]
