[{"path":[]},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement dansmith01@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://cmmr.github.io/jobqueue/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://cmmr.github.io/jobqueue/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 jobqueue authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Expressions and Variables","text":"“main” process environment (calling <Queue>$run()) isolated Worker environments. Therefore, expression (expr) data needed evaluating expr must explicitly passed Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"expressions","dir":"Articles","previous_headings":"","what":"Expressions","title":"Expressions and Variables","text":"expr parameter can given two ways. expr = { 42 } expr = quote({ 42 }) second form helpful expression needs passed around code handed <Queue>$run(). call-generating functions can used instead quote(), call() bquote().","code":"library(jobqueue) q <- Queue$new()  q$run({ 42 })$result #> [1] 42  expr <- quote({ 42 }) q$run(expr)$result #> [1] 42"},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"variables","dir":"Articles","previous_headings":"","what":"Variables","title":"Expressions and Variables","text":"Global variables can set Queue created. Additional variables Job can defined vars.","code":"globals <- list(MY_DATA = mtcars) q       <- Queue$new(globals = globals)  expr <- quote(colnames(MY_DATA)) q$run(expr)$result[1:6] #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\" expr <- quote(MY_DATA[rows,cols]) vars <- list(rows = 20:22, cols = c('mpg', 'hp', 'wt'))  q$run(expr = expr, vars = vars)$result #>                   mpg  hp    wt #> Toyota Corolla   33.9  65 1.835 #> Toyota Corona    21.5  97 2.465 #> Dodge Challenger 15.5 150 3.520"},{"path":"https://cmmr.github.io/jobqueue/articles/eval.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Expressions and Variables","text":"Minimize data transfer /Workers (’s slow). Use UPPERCASE names global variables. assigned two global variables Workers: B. also attached ‘jsonlite’ R package Workers’ search paths. expr evaluated, uses , B, toJSON Worker’s environment, x vars.","code":"library(jobqueue)  q <- Queue$new(   globals  = list(A = 1),   init     = { B <- 12 },   packages = 'jsonlite' )  job <- q$run(   'vars' = list(x = 37),    'expr' = { toJSON(c(A, B, x)) } )  job$result #> [1,12,37]"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Callback Hooks","text":"","code":"library(jobqueue) q <- Queue$new(workers = 1)"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Callback Hooks","text":"Callbacks cornerstone asynchronous programming. want calculate 2 + 2 show results, synchronous programming approach : asynchronous programming, task broken apart two discrete steps: computation result handling. Using jobqueue, looks like: asynchronous format allows parts code run independently, case separate R processes. part finishes, callback executed allow work result. Callbacks limited just Job finishing. See “State Triggers” section list events can trigger callback. Important Hooks evaluated main process, background processes. Therefore, ensure callback functions execute quickly delay Job handling.","code":"message('Result = ', 2 + 2) #> Result = 20 job <- q$run({ 2 + 2 }) job$on('done', ~message('Result = ', .$result)) #> Result = 20"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"a-callback-function","dir":"Articles","previous_headings":"","what":"A Callback Function","title":"Callback Hooks","text":"callback function accept one argument: object triggered callback. Functions accepting zero multiple arguments also allowed. great place shorthand function definitions introduced R 4.1.0. jobqueue also understands lambda syntax functions (see rlang::as_function()).","code":"# Queue Hooks hook <- function (queue) { message('Queue is ', queue$state) } hook <- \\(q) message('Queue is ', q$state) hook <- ~message('Queue is ', .$state)  # Worker Hooks hook <- function (worker) { message('Worker is ', worker$state) } hook <- \\(w) message('Worker is ', w$state) hook <- ~message('Worker is ', .$state)  # Job Hooks hook <- function (job) { message('Job is ', job$state) } hook <- \\(j) message('Job is ', j$state) hook <- ~message('Job is ', .$state)"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"triggers","dir":"Articles","previous_headings":"","what":"Triggers","title":"Callback Hooks","text":"Queue, Worker, Job objects update $state described tables . time state changes, callbacks registered state executed. addition, can register state = '*' state='.next' trigger regardless present state name.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"attaching","dir":"Articles","previous_headings":"","what":"Attaching","title":"Callback Hooks","text":"Callbacks can attached Queue, Worker, Job objects. can add callbacks either create object $new(), later $(). Queue$new(), hooks can set hooks Queue, Worker, Job objects. rules : Prefixing q_, w_, j_ attaches hook Queue, Workers, Jobs, respectively. Non-prefixed hooks attached Jobs. Alternatively, list lists can assigned hooks, format:","code":"hook <- ~message(.$uid, ' is ', .$state)  q <- Queue$new(hooks  = list(q_idle = hook)) w <- Worker$new(hooks = list(idle   = hook)) j <- Job$new(hooks    = list(done   = hook))  q$on('busy',     hook) w$on('busy',     hook) j$on('starting', hook) Queue$new(   'hooks' = list(     'queue'  = list(idle = hook),      'worker' = list(idle = hook),      'job'    = list(done = hook) ))"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"removing","dir":"Articles","previous_headings":"","what":"Removing","title":"Callback Hooks","text":"Callbacks attached $new() removed. attach callback $(), return value function, , called, remove callback object.","code":"job <- Job$new(   'expr'  = { 3.14 },    'hooks' = list(done = ~message('ABC')) )  off <- job$on('done', ~message('XYZ')) off()  q$submit(job) #> ABC"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"default-job-hooks","dir":"Articles","previous_headings":"","what":"Default Job Hooks","title":"Callback Hooks","text":"create Queue (Queue$new()), can define set callbacks automatically apply Jobs created <Queue>$run() command. Queue$new() know apply hooks Jobs instead Queues Workers? Unless otherwise indicated, Queue$new() hooks assumed Jobs. can also explicitly specify hooks Jobs using formats described “Attaching Callbacks” section . set hooks <Queue>$run(), hooks REPLACE Job hooks Queue$new().","code":"n <- 0 q <- Queue$new(hooks = list(created = ~{ n <<- n + 1 } ))  for (i in 1:5) q$run({ 'Hi' })  n #> [1] 5 q <- Queue$new(hooks = list(j_created = ~{ n <<- n + 1 } )) # or q <- Queue$new(hooks = list(job = list(created = ~{ n <<- n + 1 } ))) n <- 0 q <- Queue$new(hooks = list(created = ~{ n <<- n + 1 } ))  for (i in 1:3) q$run({ 'Hi' }, hooks = list(done = ~message(.$result))) #> Hi #> Hi #> Hi  n #> [1] 0"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"use-case-priority-setting","dir":"Articles","previous_headings":"","what":"Use Case: Priority Setting","title":"Callback Hooks","text":", ’ll set callback function triggers Job enters 'queued' state. modify Job, adding custom <Job>$priority field Job object. modify Queue’s internal list jobs (<Queue>$jobs), sorting according Job’s <Job>$priority. Last, attach additional callbacks Job output timing information upon exit 'queued’ state upon entry 'done' state. actual application, set <Job>$priority based <Job>$vars. , define custom <Job>$priority field <Queue>$run(). , set <Job>$priority hook triggers prioritize() triggered.","code":"library(glue) library(jobqueue)  # Our callback/hook function. prioritize <- function (job) {    queue      <- job$queue   queue_jobs <- job$queue$jobs    # Apply a random priority to this job.   job$priority <- round(runif(1) * 10) - 5      # Sort all this Queue's jobs by priority (including this job).   priorities     <- sapply(queue_jobs, `[[`, 'priority')   job$queue$jobs <- queue_jobs[order(priorities)]      # Add hooks to this job to report queued/total times.   t1    <- Sys.time()   tdiff <- function () format(round(Sys.time() - t1, 1))      job$on('.next', ~message(glue(     'Job {.$uid} (priority {.$priority}) was {.$state} after {tdiff()}' )))        job$on('done', ~message(glue(     'Job {.$uid} (priority {.$priority}) finished in {tdiff()}' ))) }  # A single worker best illustrates processing order. q <- Queue$new(   'workers' = 1,    'hooks'   = list(queued = prioritize) )  for (i in 1:5) {   job <- q$run({ 3.14 })   message(glue_data(job, 'Created Job {uid} with priority {priority}')) } #> Job J11 (priority -3) was dispatched after 0.1 secs #> Created Job J11 with priority -3 #> Created Job J12 with priority -2 #> Created Job J13 with priority 1 #> Created Job J14 with priority 0 #> Created Job J15 with priority -1 #> Job J11 (priority -3) finished in 0.7 secs #> Job J12 (priority -2) was dispatched after 0.6 secs #> Job J12 (priority -2) finished in 1.1 secs #> Job J15 (priority -1) was dispatched after 0.7 secs #> Job J15 (priority -1) finished in 1.3 secs #> Job J14 (priority 0) was dispatched after 1.4 secs #> Job J14 (priority 0) finished in 2 secs #> Job J13 (priority 1) was dispatched after 2.1 secs #> Job J13 (priority 1) finished in 2.6 secs prioritize <- function (job) {      # Give priority to lower number of replications   job$priority <- job$vars$replications      queue_jobs     <- job$queue$jobs   priorities     <- sapply(queue_jobs, `[[`, 'priority')   job$queue$jobs <- queue_jobs[order(priorities)] } q <- Queue$new(hooks = list(queued = prioritize))  #                                        vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv for (reps in 5:1) job <- q$run({ 3.14 }, vars = list(replications = reps)) prioritize <- function (job) {   queue_jobs     <- job$queue$jobs   priorities     <- sapply(queue_jobs, `[[`, 'priority')   job$queue$jobs <- queue_jobs[order(priorities)] } q <- Queue$new(hooks = list(queued = prioritize))  #                                        vvvvvvvvvvvvvvv for (reps in 5:1) job <- q$run({ 3.14 }, priority = reps) set_priority <- function (job) {   job$priority <- job$vars$replications }  prioritize <- function (job) {   queue_jobs     <- job$queue$jobs   priorities     <- sapply(queue_jobs, `[[`, 'priority')   job$queue$jobs <- queue_jobs[order(priorities)] }  #                           vvvvvvvvvvvvvvvvvvvvvv q <- Queue$new(hooks = list(created = set_priority, queued = prioritize)) for (reps in 5:1) job <- q$run({ 3.14 }, vars = list(replications = reps))"},{"path":"https://cmmr.github.io/jobqueue/articles/hooks.html","id":"use-case-rate-limiting","dir":"Articles","previous_headings":"","what":"Use Case: Rate Limiting","title":"Callback Hooks","text":"Say ’re hosting web service, users allowed submit one Job every 30 seconds. Jobs can take 30 seconds, solution complex setting stop_id = user_id. want stop new Job instead old one? Note code won’t completely solve rate limiting task. user’s Job takes five seconds complete, submit Job every six seconds Queue none wiser. give Queue awareness previously completed Jobs, ’ll need persistently store per-user Job start times - like solution. first example, attached hook 'submitted' ’s <Job>$queue becomes available callbacks. latter example, attached hook 'created' instead didn’t need <Job>$queue solution. Check trigger order listed “Callback Triggers” section , attach callbacks early possible expedite Job handling.","code":"rate_limit <- function (job) {    job$t_start <- Sys.time()    for (j in job$queue$jobs)     if (j$user_id == job$user_id)       if (job$t_start - j$t_start < 30)         job$stop('Rate Limit Exceeded') }  q <- Queue$new(hooks = list(submitted = rate_limit))  j_A1 <- q$run({ 42 }, user_id = 'A') j_B1 <- q$run({ 42 }, user_id = 'B') j_B2 <- q$run({ 42 }, user_id = 'B')  j_B1$result #> [1] 42  j_B2$result #> <interrupt: Rate Limit Exceeded> t_user <- list()  rate_limit <- function (job) {   t_start <- Sys.time()   t_diff  <- t_user[[job$user_id]] - t_start   if (isTRUE(t_diff < 30)) { job$stop('Rate Limit Exceeded')   }   else                     { t_user[[job$user_id]] <<- t_start } }  q <- Queue$new(hooks = list(created = rate_limit))"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"create-a-queue","dir":"Articles","previous_headings":"","what":"Create a Queue","title":"Introduction to jobqueue","text":"create Queue, several Worker processes created background. can evaluate R code background processes main R process free work. Important background processes persisent R sessions. Avoid modifying .GlobalEnv, otherwise R code produce different results based Worker evaluates .","code":"library(jobqueue) q <- Queue$new()"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"create-a-job","dir":"Articles","previous_headings":"","what":"Create a Job","title":"Introduction to jobqueue","text":"Main article: vignette('eval') Job begin evaluating immediately, assuming Jobs ahead Queue.","code":"job <- q$run({ paste('Hello', 'World!') })"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"access-the-result","dir":"Articles","previous_headings":"","what":"Access the Result","title":"Introduction to jobqueue","text":"Main article: vignette('results') Running <Job>$result block Job finishes result ready.","code":"job$result #> [1] \"Hello World!\""},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"add-a-callback-hook","dir":"Articles","previous_headings":"","what":"Add a Callback Hook","title":"Introduction to jobqueue","text":"Main article: vignette('hooks') Adding callback hook trigger Job done allows result handled without blocking main R process.","code":"job$on('done', function (job) message(job$result)) #> [1] \"Hello World!\""},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"interrupt-evaluation","dir":"Articles","previous_headings":"","what":"Interrupt Evaluation","title":"Introduction to jobqueue","text":"Main article: vignette('stops') Job’s result longer needed want free compute resources, calling <Job>$stop() terminate background process. Terminated background process automatically replaced new ones.","code":"job <- q$run({ Sys.sleep(10); 'Zzzzz' }) job$stop() job$result #> <interrupt: job stopped by user>"},{"path":"https://cmmr.github.io/jobqueue/articles/jobqueue.html","id":"passing-data","dir":"Articles","previous_headings":"","what":"Passing Data","title":"Introduction to jobqueue","text":"","code":"# Variables to permanently store on the Worker. q <- Queue$new(globals = list(MY_DATA = mtcars))  # Variables to temporary add to the Worker. vars <- list(n = 2, fields = c('mpg', 'cyl', 'disp'))  # The expression to evaluate on the Worker. expr <- quote(head(MY_DATA, n)[,fields])  job <- q$run(expr = expr, vars = vars)  job$result #>               mpg cyl disp #> Mazda RX4      21   6  160 #> Mazda RX4 Wag  21   6  160"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"reacting-to-results","dir":"Articles","previous_headings":"","what":"Reacting to Results","title":"Result and Error Handling","text":"See also vignette('hooks')","code":"my_job <- q$run({ 42 })  # ===  A 'jobqueue'-style callback  ============ my_job$on('done', ~message('Result = ', .$result)) #> Result = 42  # ===  A 'promises'-style callback  ============ my_job %...>% message('Result = ', .) #> Result = 42"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"output-vs-result","dir":"Articles","previous_headings":"","what":"Output vs Result","title":"Result and Error Handling","text":"expr finished evaluating, result assigned <Job>$output. default, <Job>$result return exact value <Job>$output. However, <Job>$output fixed value, <Job>$result highly configurable. notably reformat signal parameters.","code":"job <- q$run({ 42 })  job$output #> [1] 42 job$result #> [1] 42"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"reformatting-output","dir":"Articles","previous_headings":"","what":"Reformatting Output","title":"Result and Error Handling","text":"Use reformat = function (job) {...} define returned <Job>$result. Important may access job$output reformat function. access job$result, start infinite recusion. reformat can set several places: Queue$new(reformat = http_wrap) Job$new(reformat = http_wrap) <Queue>$run(reformat = http_wrap) <Job>$reformat <- http_wrap","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"transformation","dir":"Articles","previous_headings":"Reformatting Output","what":"Transformation","title":"Result and Error Handling","text":"","code":"http_wrap <- function (job) {   result <- job$output   paste0('{\"status\":200,\"body\":{\"result\":', result, '}}') }  job <- q$run({ 42 }, reformat = http_wrap) cat(job$result) #> {\"status\":200,\"body\":{\"result\":42}}"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"job-details","dir":"Articles","previous_headings":"Reformatting Output","what":"Job Details","title":"Result and Error Handling","text":"","code":"with_id <- function (job) {   list(result = job$output, id = job$id) }  job <- q$run({ 42 }, reformat = with_id, id = 'abc') dput(job$result) #> list(result = 42, id = \"abc\")"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"non-blocking","dir":"Articles","previous_headings":"Reformatting Output","what":"Non-blocking","title":"Result and Error Handling","text":"<Job>$output blocks Job done. want <Job>$result block, can return placeholder value instead.","code":"reformat <- function (job) {   if (job$is_done) { job$output$result          }   else             { 'result not available yet' } }  job <- q$run({ Sys.sleep(5); 42 }, reformat = reformat) job$result #> [1] \"result not available yet\"  job$state #> [1] \"running\""},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"signaling-errors","dir":"Articles","previous_headings":"","what":"Signaling Errors","title":"Result and Error Handling","text":"default, errors interrupts caught jobqueue returned condition object <Job>$result. want errors continue propagating, set signal = TRUE. signals can caught usual try() tryCatch(). can also signal conditions catching others. Perhaps stopping job part “normal” workflow shouldn’t lumped errors.","code":"expr <- quote(stop('error XYZ'))  job <- q$run(expr) x   <- job$result  inherits(x, 'condition') #> TRUE  x #> Error in `q$run(expr)`: #> ! Error evaluating <Job>$expr on background process #> Caused by error in `stop(\"error XYZ\")`: #> ! error XYZ #> --- #> Subprocess backtrace: #> 1. base::eval(expr = expr, envir = vars, enclos = .GlobalEnv) #> 2. base::stop(\"error XYZ\") #> 3. | base::.handleSimpleError(function (e) … #> 4. global h(simpleError(msg, call)) job <- q$run(expr, signal = TRUE) x   <- job$result #> Error in \"q$run(expr, signal = TRUE)\" :  #>    ! Error evaluating <Job>$expr on background process #>  Caused by error in `stop(\"error XYZ\")`: #>  ! error XYZ print_cnd <- function (cnd) cli::cli_text('Caught {.type {cnd}}.')  job <- q$run({ Sys.sleep(5) }, signal = TRUE)$stop() res <- tryCatch(job$result, error = print_cnd, interrupt = print_cnd) #> Caught an <interrupt> object.  res #> NULL  job <- q$run({ stop('error XYZ') }, signal = TRUE) res <- tryCatch(job$result, error = print_cnd, interrupt = print_cnd) #> Caught an <error> object.  res #> NULL job <- q$run({ Sys.sleep(5) }, signal = 'error')$stop() res <- tryCatch(job$result, error = print_cnd)  res #> <interrupt: job stopped by user>  job <- q$run({ stop('error XYZ') }, signal = 'error') res <- tryCatch(job$result, error = print_cnd) #> Caught an <error> object.  res #> NULL"},{"path":"https://cmmr.github.io/jobqueue/articles/results.html","id":"promise-handling","dir":"Articles","previous_headings":"","what":"Promise Handling","title":"Result and Error Handling","text":"can pass Job directly function expects ‘promise’ object, promises::promises::%...>%. functions re-exported jobqueue, calling library(promises) optional. default, errors interrupts caught jobqueue used promise fulfillment. Setting signal = TRUE cause errors interrupts sent promise’s rejection handler instead.","code":"q$run({ 42 }) %...>% message #> 42 onFulfilled <- function (value) cli::cli_text('Fulfilled with {.type {value}}.') onRejected  <- function (err)   cli::cli_text('Rejected with {.type {err}}.')  job <- q$run({ Sys.sleep(5) })$stop() job %>% then(onFulfilled, onRejected) #> Fulfilled with an <interrupt> object.  job <- q$run({ stop('error XYZ') }) job %>% then(onFulfilled, onRejected) #> Fulfilled with an <error> object. job <- q$run({ Sys.sleep(5) }, signal = TRUE)$stop() job %>% then(onFulfilled, onRejected) #> Rejected with an <interrupt> object.  job <- q$run({ stop('error XYZ') }, signal = TRUE) job %>% then(onFulfilled, onRejected) #> Rejected with an <error> object."},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Stopping Jobs","text":"can save compute resources stopping execution Jobs longer needed. Job currently running Worker, associated background process terminated. Terminated background process automatically replaced new ones. several ways stop Job: <Job>$stop(): return interrupt condition. <Job>$output<-: return custom result. <Job>$stop_id: replace redundant Jobs. <Job>$copy_id: combine redundant Jobs. <Job>$timeout: cap Job’s compute time.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Stopping Jobs","text":"","code":"library(jobqueue) q <- Queue$new(workers = 1)"},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"immediate-stop","dir":"Articles","previous_headings":"","what":"Immediate Stop","title":"Stopping Jobs","text":"soon Job created, can stopped either calling <Job>$stop() assigning <Job>$output. methods work Job state 'done'. Job state 'done', <Job>$output immutable calling <Job>$stop() effect (since ’s already stopped). Calling <Job>$stop() assigning <Job>$output side effect setting Job state 'done'.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"interrupting-with-jobstop","dir":"Articles","previous_headings":"Immediate Stop","what":"Interrupting with <Job>$stop()","title":"Stopping Jobs","text":"can call <Job>$stop() within callback hooks.","code":"job <- Job$new({ Sys.sleep(5); 10 }) job$stop() job$result #> <interrupt: job stopped by user>  job <- Job$new({ Sys.sleep(5); 10 }) job$stop('my reason') job$result #> <interrupt: my reason>  class(job$result) #> [1] \"interrupt\" \"condition\" hooks <- list(   'created' = function (job) {     if (length(job$vars$x) > 100)       job$stop('Job is too large.')   } )  job <- q$run({ sum(x) }, vars = list(x = 1:200), hooks = hooks) job$result #> <interrupt: Job is too large.>"},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"assigning-to-joboutput","dir":"Articles","previous_headings":"Immediate Stop","what":"Assigning to <Job>$output","title":"Stopping Jobs","text":"<Job>$output can assigned . Job yet done <Job>$output assigned, ongoing processing halted. ’ve set <Job>$reformat, determine <Job>$result usual. See vignette('results').","code":"job <- Job$new({ Sys.sleep(5); 10 })  job$state #> [1] \"created\"  job$output <- \"Custom result\"  job$state #> [1] \"done\"  job$result #> [1] \"Custom result\""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"replacing-and-combining","dir":"Articles","previous_headings":"","what":"Replacing and Combining","title":"Stopping Jobs","text":"Sometimes repeat jobs may sent Queue, instance, user clicking ‘submit’ button repeatedly. stop_id copy_id can prevent requests overloading server.","code":""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"stop-id","dir":"Articles","previous_headings":"Replacing and Combining","what":"Stop ID","title":"Stopping Jobs","text":"New jobs replace existing jobs stop_id.","code":"job1 <- q$run({ Sys.sleep(5); 'A' }, stop_id = 123) job2 <- q$run({ 'B' },               stop_id = 123) job1$result #> <interrupt: duplicated stop_id> job2$result #> [1] \"B\""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"copy-id","dir":"Articles","previous_headings":"Replacing and Combining","what":"Copy ID","title":"Stopping Jobs","text":"New jobs mirror output existing jobs copy_id.","code":"job1 <- q$run({ Sys.sleep(5); 'A' }, copy_id = 456) job2 <- q$run({ 'B' },               copy_id = 456) job1$result #> [1] \"A\" job2$result #> [1] \"A\""},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"in-queuenew","dir":"Articles","previous_headings":"Replacing and Combining","what":"In Queue$new()","title":"Stopping Jobs","text":"set stop_id /copy_id Queue$new(), must functions (lambda notation functions) accept Job object input returns value id. id NULL, comparisons done. Otherwise, id can data type compared ids identical().","code":"q <- Queue$new(stop_id = function (job) list(job$vars$f, job$user_id))  job1 <- q$run({ f(x) }, vars = list(f = sum,  x = 1:10), user_id = 'A') job2 <- q$run({ f(x) }, vars = list(f = sum,  x = 1:2),  user_id = 'A') job3 <- q$run({ f(x) }, vars = list(f = mean, x = 1:10), user_id = 'A')  job1$result #> <interrupt: duplicated stop_id> job2$result #> [1] 3 job3$result #> [1] 5.5"},{"path":"https://cmmr.github.io/jobqueue/articles/stops.html","id":"timeouts","dir":"Articles","previous_headings":"","what":"Timeouts","title":"Stopping Jobs","text":"Limits (seconds) can set : total 'submitted' 'done' time: timeout = 2 per-state basis: timeout = list(queued = 1, running = 2) : timeout = list(total = 3, queued = 2, running = 2)","code":"job <- Job$new({ Sys.sleep(5); 'Zzzzz' }, timeout = 0.2) q$submit(job) job$result #> <interrupt: total runtime exceeded 0.2 seconds>  job <- Job$new({ 10 }, timeout = list(created = 0.2)) job$result #> <interrupt: exceeded 0.2 seconds while in \"created\" state>"},{"path":"https://cmmr.github.io/jobqueue/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel P. Smith. Author, maintainer. Alkek Center Metagenomics Microbiome Research. Copyright holder, funder.","code":""},{"path":"https://cmmr.github.io/jobqueue/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith D (2025). jobqueue: Run Interruptible Code Asynchronously. R package version 1.2.0, https://github.com/cmmr/jobqueue, https://cmmr.github.io/jobqueue/.","code":"@Manual{,   title = {jobqueue: Run Interruptible Code Asynchronously},   author = {Daniel P. Smith},   year = {2025},   note = {R package version 1.2.0, https://github.com/cmmr/jobqueue},   url = {https://cmmr.github.io/jobqueue/}, }"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"jobqueue","dir":"","previous_headings":"","what":"Run Interruptible Code Asynchronously","title":"Run Interruptible Code Asynchronously","text":"goals jobqueue : Run jobs parallel background processes. Allow jobs stopped point. Process job results asynchronous callbacks.","code":""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Run Interruptible Code Asynchronously","text":"","code":"# Install the latest stable version from CRAN: install.packages(\"jobqueue\")  # Or the development version from GitHub: install.packages(\"pak\") pak::pak(\"cmmr/jobqueue\")"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Run Interruptible Code Asynchronously","text":"","code":"library(jobqueue)  q <- Queue$new()  job <- q$run({ paste('Hello', 'world!') }) job$result #> [1] \"Hello world!\""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"asynchronous-callbacks","dir":"","previous_headings":"","what":"Asynchronous Callbacks","title":"Run Interruptible Code Asynchronously","text":"Main article: vignette('hooks')","code":"j <- q$run(   expr  = { 42 },    hooks = list(     'created' = ~{ message(\"We're uid '\", .$uid, \"'.\") },     '*'       = ~{ message('  - ', .$state) })) #> We're uid 'J2'. #>   - created #>   - submitted #>   - queued #>   - assigned #>   - dispatched #>   - running #>   - done  j$on('done', function (job) message('result = ', job$result)) #> result = 42"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"converting-to-promises","dir":"","previous_headings":"Asynchronous Callbacks","what":"Converting to Promises","title":"Run Interruptible Code Asynchronously","text":"See also https://rstudio.github.io/promises/","code":"job      <- q$run({ 3.14 }) callback <- function (result) message('resolved with: ', result)  job %...>% callback #> resolved with: 3.14  job %>% then(callback) #> resolved with: 3.14  as.promise(job)$then(callback) #> resolved with: 3.14"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"shiny-integration","dir":"","previous_headings":"Asynchronous Callbacks","what":"Shiny Integration","title":"Run Interruptible Code Asynchronously","text":"See also https://rstudio.github.io/promises/articles/promises_06_shiny.html","code":"function(input, output, session) {   output$plot <- renderPlot({     q$run({ read.table(url) }, list(url = input$url)) %...>%       head(input$n) %...>%       plot()   }) }"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"stopping-jobs","dir":"","previous_headings":"","what":"Stopping Jobs","title":"Run Interruptible Code Asynchronously","text":"running job stopped, background process terminated. Terminated background process automatically replaced new ones. Stopped jobs return condition object class ‘interrupt’ result. Main article: vignette('stops')","code":""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"manually","dir":"","previous_headings":"Stopping Jobs","what":"Manually","title":"Run Interruptible Code Asynchronously","text":"custom message can also given, e.g. job$stop('reason'), returned condition object.","code":"job <- q$run({ Sys.sleep(2); 'Zzzzz' }) job$stop() job$result #> <interrupt: job stopped by user>"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"runtime-limits","dir":"","previous_headings":"Stopping Jobs","what":"Runtime Limits","title":"Run Interruptible Code Asynchronously","text":"Limits (seconds) can set : total ‘submitted’ ‘done’ time: timeout = 2 per-state basis: timeout = list(queued = 1, running = 2) : timeout = list(total = 3, queued = 2, running = 2)","code":"job <- q$run({ Sys.sleep(2); 'Zzzzz' }, timeout = 0.2) job$result #> <interrupt: total runtime exceeded 0.2 seconds>"},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"stop-id","dir":"","previous_headings":"Stopping Jobs","what":"Stop ID","title":"Run Interruptible Code Asynchronously","text":"New jobs replace existing jobs stop_id.","code":"job1 <- q$run({ Sys.sleep(1); 'A' }, stop_id = 123) job2 <- q$run({ 'B' },               stop_id = 123) job1$result #> <interrupt: duplicated stop_id> job2$result #> [1] \"B\""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"copy-id","dir":"","previous_headings":"Stopping Jobs","what":"Copy ID","title":"Run Interruptible Code Asynchronously","text":"New jobs mirror output existing jobs copy_id.","code":"job1 <- q$run({ Sys.sleep(1); 'A' }, copy_id = 456) job2 <- q$run({ 'B' },               copy_id = 456) job1$result #> [1] \"A\" job2$result #> [1] \"A\""},{"path":"https://cmmr.github.io/jobqueue/index.html","id":"variables","dir":"","previous_headings":"","what":"Variables","title":"Run Interruptible Code Asynchronously","text":"","code":"q    <- Queue$new(globals = list(G = 8)) expr <- quote(c(x = x , y = y, G = G)) job  <- q$run(expr, vars = list(x = 10, y = 2))  dput(job$result) #> c(x = 10, y = 2, G = 8)"},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":null,"dir":"Reference","previous_headings":"","what":"How to Evaluate an R Expression — Job","title":"How to Evaluate an R Expression — Job","text":"Job object encapsulates expression evaluation parameters. also provides way check retrieve result.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"How to Evaluate an R Expression — Job","text":"expr R expression run Job. vars Get set - List variables placed expression's environment evaluation. reformat Get set - function (job) defining <Job>$result. signal Get set - Conditions signal. cpus Get set - Number CPUs reserve evaluating expr. timeout Get set - Time limits apply Job. proxy Get set - Job proxy place running expr. state Get set - Job's state: 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done'. Assigning <Job>$state trigger callback hooks. output Get set - Job's raw output. Assigning <Job>$output change Job's state 'done'. result Result expr. block Job finished. hooks Currently registered callback hooks named list functions. Set new hooks <Job>$(). is_done TRUE FALSE depending Job's result ready. uid short string, e.g. 'J16', uniquely identifies Job.","code":""},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"How to Evaluate an R Expression — Job","text":"Job$new() Job$print() Job$() Job$wait() Job$stop()","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"How to Evaluate an R Expression — Job","text":"Creates Job object defining run expression background worker process. Typically need call Job$new(). Instead, create Queue use <Queue>$run() generate Job objects.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"How to Evaluate an R Expression — Job","text":"","code":"Job$new(   expr,   vars = NULL,   timeout = NULL,   hooks = NULL,   reformat = NULL,   signal = FALSE,   cpus = 1L,   ... )"},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"How to Evaluate an R Expression — Job","text":"expr call R expression wrapped curly braces evaluate worker. access variables defined vars, well Worker's globals, packages, init configuration. See vignette('eval'). vars named list variables make available expr evaluation. Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. function (job) returns object. timeout named numeric vector indicating maximum number seconds allowed state job passes , 'total' apply single timeout 'submitted' 'done'. function (job) returns . Example: timeout = c(total = 2.5, running = 1). See vignette('stops'). hooks named list functions run Job state changes, form hooks = list(created = function (worker) {...}). function (job) returns . Names worker hooks typically 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done', '*' (duplicates okay). See vignette('hooks'). reformat Set reformat = function (job) define <Job>$result return. default, reformat = NULL passes <Job>$output <Job>$result unchanged. See vignette('results'). signal calling <Job>$result signal condition objects? FALSE, <Job>$result return object without taking additional action. Setting TRUE character vector condition classes, e.g. c('interrupt', 'error', 'warning'), cause equivalent stop(<condition>) called conditions produced. Alternatively, function (job) returns TRUE FALSE. See vignette('results'). cpus many CPU cores reserve Job.  function (job) returns . Used limit number Jobs running simultaneously respect <Queue>$max_cpus. prevent Job using CPUs reserved. ... Arbitrary named values add returned Job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"How to Evaluate an R Expression — Job","text":"Job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"How to Evaluate an R Expression — Job","text":"Print method Job.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"How to Evaluate an R Expression — Job","text":"","code":"Job$print(...)"},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"How to Evaluate an R Expression — Job","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"How to Evaluate an R Expression — Job","text":"Job, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"method-on-","dir":"Reference","previous_headings":"","what":"Method on()","title":"How to Evaluate an R Expression — Job","text":"Attach callback function execute Job enters state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"How to Evaluate an R Expression — Job","text":"","code":"Job$on(state, func)"},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"How to Evaluate an R Expression — Job","text":"state name Job state. Typically one : '*' -          Every time state changes. '.next' -      one time, next time state changes. 'created' -    Job$new() initialization. 'submitted' -  <Job>$queue assigned. 'queued' -     stop_id copy_id resolved. 'dispatched' - <Job>$worker assigned. 'starting' -   evaluation begins. 'running' -    evaluation begins. 'done' -       <Job>$output assigned. Custom states can also specified. func function accepts Job object input. can call <Job>$stop() edit <Job>$ values changes persisted (since Jobs reference class objects). can also edit/stop queued jobs modifying Jobs <Job>$queue$jobs. Return value ignored.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"How to Evaluate an R Expression — Job","text":"function called removes callback Job.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"method-wait-","dir":"Reference","previous_headings":"","what":"Method wait()","title":"How to Evaluate an R Expression — Job","text":"Blocks Job enters given state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"How to Evaluate an R Expression — Job","text":"","code":"Job$wait(state = \"done\")"},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"How to Evaluate an R Expression — Job","text":"state name Job state. Typically one : '*' -          Every time state changes. '.next' -      one time, next time state changes. 'created' -    Job$new() initialization. 'submitted' -  <Job>$queue assigned. 'queued' -     stop_id copy_id resolved. 'dispatched' - <Job>$worker assigned. 'starting' -   evaluation begins. 'running' -    evaluation begins. 'done' -       <Job>$output assigned. Custom states can also specified.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"How to Evaluate an R Expression — Job","text":"Job, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"How to Evaluate an R Expression — Job","text":"Stop Job. Job running, Worker restarted.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"How to Evaluate an R Expression — Job","text":"","code":"Job$stop(reason = \"job stopped by user\", cls = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"How to Evaluate an R Expression — Job","text":"reason message include 'interrupt' condition object returned Job's result. cls Character vector additional classes prepend c('interrupt', 'condition').","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Job.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"How to Evaluate an R Expression — Job","text":"Job, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigns Jobs to a Set of Workers — Queue","title":"Assigns Jobs to a Set of Workers — Queue","text":"Jobs go . Results come .","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Assigns Jobs to a Set of Workers — Queue","text":"hooks named list currently registered callback hooks. jobs Get set - List Jobs currently managed Queue. state Queue's state: 'starting', 'idle', 'busy', 'stopped', 'error.' uid Get set - Unique identifier, e.g. 'Q1'. tmp Queue's temporary directory. workers Get set - List Workers used processing Jobs.","code":""},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Assigns Jobs to a Set of Workers — Queue","text":"Queue$new() Queue$print() Queue$run() Queue$submit() Queue$wait() Queue$() Queue$stop()","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Creates pool background processes handling $run() $submit() calls. workers initialized according globals, packages, init arguments.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$new(   globals = NULL,   packages = NULL,   init = NULL,   max_cpus = availableCores(),   workers = ceiling(max_cpus * 1.2),   timeout = NULL,   hooks = NULL,   reformat = NULL,   signal = FALSE,   cpus = 1L,   stop_id = NULL,   copy_id = NULL )"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"globals named list variables <Job>$exprs access . Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. packages Character vector package names load workers. init call R expression wrapped curly braces evaluate worker just , immediately start-. access variables defined globals assets packages. Returned value ignored. max_cpus Total number CPU cores can reserved running Jobs (sum(<Job>$cpus)). enforce limits actual CPU utilization. workers many background Worker processes start. Set max_cpus enable standby Workers quickly swap Workers need restart. timeout, hooks, reformat, signal, cpus, stop_id, copy_id Defaults Queue's $run() method. , stop_id copy_id must either function (job) NULL. hooks can set queue, worker, /job hooks - see \"Attaching\" section vignette('hooks').","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to a Set of Workers — Queue","text":"Queue object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Print method Queue.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$print(...)"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-run-","dir":"Reference","previous_headings":"","what":"Method run()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Creates Job object submits queue running. NA arguments replaced value Queue$new().","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$run(   expr,   vars = list(),   timeout = NA,   hooks = NA,   reformat = NA,   signal = NA,   cpus = NA,   stop_id = NA,   copy_id = NA,   ... )"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"expr call R expression wrapped curly braces evaluate worker. access variables defined vars, well Worker's globals, packages, init configuration. See vignette('eval'). vars named list variables make available expr evaluation. Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. function (job) returns object. timeout named numeric vector indicating maximum number seconds allowed state job passes , 'total' apply single timeout 'submitted' 'done'. function (job) returns . Example: timeout = c(total = 2.5, running = 1). See vignette('stops'). hooks named list functions run Job state changes, form hooks = list(created = function (worker) {...}). function (job) returns . Names worker hooks typically 'created', 'submitted', 'queued', 'dispatched', 'starting', 'running', 'done', '*' (duplicates okay). See vignette('hooks'). reformat Set reformat = function (job) define <Job>$result return. default, reformat = NULL passes <Job>$output <Job>$result unchanged. See vignette('results'). signal calling <Job>$result signal condition objects? FALSE, <Job>$result return object without taking additional action. Setting TRUE character vector condition classes, e.g. c('interrupt', 'error', 'warning'), cause equivalent stop(<condition>) called conditions produced. Alternatively, function (job) returns TRUE FALSE. See vignette('results'). cpus many CPU cores reserve Job.  function (job) returns . Used limit number Jobs running simultaneously respect <Queue>$max_cpus. prevent Job using CPUs reserved. stop_id existing Job Queue stop_id, Job stopped return 'interrupt' condition object result. stop_id can also function (job) returns stop_id assign given Job. stop_id NULL disables feature. See vignette('stops'). copy_id existing Job Queue copy_id, newly submitted Job become \"proxy\" earlier Job, returning whatever result earlier Job returns. copy_id can also function (job) returns copy_id assign given Job. copy_id NULL disables feature. See vignette('stops'). ... Arbitrary named values add returned Job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to a Set of Workers — Queue","text":"new Job object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-submit-","dir":"Reference","previous_headings":"","what":"Method submit()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Adds Job Queue running background process.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$submit(job)"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"job Job object, created Job$new().","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to a Set of Workers — Queue","text":"Queue, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-wait-","dir":"Reference","previous_headings":"","what":"Method wait()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Blocks Queue enters given state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$wait(state = \"idle\")"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"state name Queue state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - Workers starting. 'idle' -     workers ready/idle. 'busy' -     least one worker busy. 'stopped' -  Shutdown complete. 'error' -    Workers start cleanly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to a Set of Workers — Queue","text":"Queue, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-on-","dir":"Reference","previous_headings":"","what":"Method on()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Attach callback function execute Queue enters state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$on(state, func)"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"state name Queue state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - Workers starting. 'idle' -     workers ready/idle. 'busy' -     least one worker busy. 'stopped' -  Shutdown complete. 'error' -    Workers start cleanly. func function accepts Queue object input. Return value ignored.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to a Set of Workers — Queue","text":"function called removes callback Queue.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"Assigns Jobs to a Set of Workers — Queue","text":"Stop jobs workers.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns Jobs to a Set of Workers — Queue","text":"","code":"Queue$stop(reason = \"job queue shut down by user\", cls = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns Jobs to a Set of Workers — Queue","text":"reason Passed <Job>$stop() Jobs currently managed Queue. cls Passed <Job>$stop() Jobs currently managed Queue.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Queue.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Assigns Jobs to a Set of Workers — Queue","text":"Queue, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":null,"dir":"Reference","previous_headings":"","what":"A Background Process — Worker","title":"A Background Process — Worker","text":"Job expressions evaluated.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"A Background Process — Worker","text":"hooks named list currently registered callback hooks. job currently running Job. ps ps::ps_handle() object background process. reason Worker stopped. state Worker's state: 'starting', 'idle', 'busy', 'stopped'. uid short string, e.g. 'W11', uniquely identifies Worker. tmp Worker's temporary directory.","code":""},{"path":[]},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"A Background Process — Worker","text":"Worker$new() Worker$print() Worker$start() Worker$stop() Worker$restart() Worker$() Worker$wait() Worker$run()","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"A Background Process — Worker","text":"Creates background R process running Jobs.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$new(globals = NULL, packages = NULL, init = NULL, hooks = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"globals named list variables <Job>$exprs access . Alternatively, object can coerced named list .list(), e.g. named vector, data.frame, environment. packages Character vector package names load workers. init call R expression wrapped curly braces evaluate worker just , immediately start-. access variables defined globals assets packages. Returned value ignored. hooks named list functions run Worker state changes, form hooks = list(idle = function (worker) {...}). Names worker hooks typically starting, idle, busy, stopped, '*' (duplicates okay). See vignette('hooks').","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker object.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"A Background Process — Worker","text":"Print method Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$print(...)"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"... Arguments used currently.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-start-","dir":"Reference","previous_headings":"","what":"Method start()","title":"A Background Process — Worker","text":"Restarts stopped Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$start()"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-stop-","dir":"Reference","previous_headings":"","what":"Method stop()","title":"A Background Process — Worker","text":"Stops Worker terminating background process calling <Job>$stop(reason) Jobs currently assigned Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$stop(reason = \"worker stopped by user\", cls = NULL)"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"reason Passed <Job>$stop() Jobs currently managed Worker. cls Passed <Job>$stop() Jobs currently managed Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-restart-","dir":"Reference","previous_headings":"","what":"Method restart()","title":"A Background Process — Worker","text":"Restarts Worker calling <Worker>$stop(reason) <Worker>$start() succession.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$restart(reason = \"restarting worker\")"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"reason Passed <Job>$stop() Jobs currently managed Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-on-","dir":"Reference","previous_headings":"","what":"Method on()","title":"A Background Process — Worker","text":"Attach callback function execute Worker enters state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$on(state, func)"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"state name Worker state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - Waiting background process load. 'idle' -     Waiting Jobs $run(). 'busy' -     Job running. 'stopped' -  <Worker>$stop() called. func function accepts Worker object input. can call <Worker>$stop() <Worker>$ methods.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"function called removes callback Worker.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-wait-","dir":"Reference","previous_headings":"","what":"Method wait()","title":"A Background Process — Worker","text":"Blocks Worker enters given state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$wait(state = \"idle\")"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"state name Worker state. Typically one : '*' -        Every time state changes. '.next' -    one time, next time state changes. 'starting' - Waiting background process load. 'idle' -     Waiting Jobs $run(). 'busy' -     Job running. 'stopped' -  <Worker>$stop() called.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"method-run-","dir":"Reference","previous_headings":"","what":"Method run()","title":"A Background Process — Worker","text":"Assigns Job Worker evaluation background process. Worker must 'idle' state.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"A Background Process — Worker","text":"","code":"Worker$run(job)"},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Background Process — Worker","text":"job Job object, created Job$new().","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/Worker.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"A Background Process — Worker","text":"Worker, invisibly.","code":""},{"path":"https://cmmr.github.io/jobqueue/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. later later, run_now magrittr %<>%, %>% parallelly availableCores promises %...>%, %...T>%, .promise, promise_all, promise_map, promise_race, promise_reduce, ","code":""},{"path":"https://cmmr.github.io/jobqueue/news/index.html","id":"jobqueue-120","dir":"Changelog","previous_headings":"","what":"jobqueue 1.2.0","title":"jobqueue 1.2.0","text":"Allow functions job arguments. Re-export parallelly::availableCores(). Disable max_cpu tests CRAN.","code":""},{"path":"https://cmmr.github.io/jobqueue/news/index.html","id":"jobqueue-101","dir":"Changelog","previous_headings":"","what":"jobqueue 1.0.1","title":"jobqueue 1.0.1","text":"CRAN release: 2025-01-30 Initial CRAN submission.","code":""}]
